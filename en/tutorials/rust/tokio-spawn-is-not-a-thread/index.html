<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Stop treating tokio::spawn as a thread! I launched 1000 tasks in 2 seconds and the system stayed calm | 梦兽编程</title><meta name=keywords content="Rust,Tokio,async,coroutines,concurrency,tokio::spawn,task scheduler,backend"><meta name=description content="tokio::spawn is not a thread but a lightweight task. Under Tokio's scheduler you build highly concurrent services with sleep, timeout and select — 1000 tasks in 2 seconds with negligible overhead."><meta name=author content="Rexai Programming"><link rel=canonical href=https://rexai.top/en/tutorials/rust/tokio-spawn-is-not-a-thread/><link crossorigin=anonymous href=/assets/css/stylesheet.0b35afafaf160405c18d14073bc3e7f69e9bebb655c929b842ede7450e458ede.css integrity="sha256-CzWvr68WBAXBjRQHO8Pn9p6b67ZVySm4Qu3nRQ5Fjt4=" rel="preload stylesheet" as=style><link rel=icon href=https://rexai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rexai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rexai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://rexai.top/apple-touch-icon.png><link rel=mask-icon href=https://rexai.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/><link rel=alternate hreflang=en href=https://rexai.top/en/tutorials/rust/tokio-spawn-is-not-a-thread/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/extended/modern-typography.min.css integrity><style>.promotion-section{margin-top:3rem;padding:2rem;text-align:center;background:linear-gradient(135deg,rgba(59,130,246,5%) 0%,rgba(139,92,246,5%) 100%);border-radius:16px;border:1px solid rgba(59,130,246,.1);position:relative;overflow:hidden}.promotion-section::before{content:"";position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#3b82f6,#8b5cf6,#06b6d4);border-radius:16px 16px 0 0}.promotion-section h3{margin-bottom:1.5rem;color:var(--primary);font-size:1.5rem;font-weight:600;background:linear-gradient(135deg,#3b82f6,#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.qr-codes{display:flex;gap:2.5rem;justify-content:center;flex-wrap:wrap;margin-top:2rem}.qr-item{text-align:center;position:relative;transition:transform .3s ease}.qr-item:hover{transform:translateY(-5px)}.qr-item img{width:160px;height:160px;border:2px solid #e5e7eb;border-radius:16px;padding:12px;background:#fff;box-shadow:0 4px 20px rgba(0,0,0,8%),0 1px 3px rgba(0,0,0,.1);transition:all .3s ease;position:relative;overflow:hidden}.qr-item img::before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,rgba(59,130,246,.1),rgba(139,92,246,.1));opacity:0;transition:opacity .3s ease;z-index:1}.qr-item:hover img{border-color:#3b82f6;box-shadow:0 8px 30px rgba(59,130,246,.2),0 2px 8px rgba(0,0,0,.1);transform:scale(1.02)}.qr-item:hover img::before{opacity:1}.qr-item p{margin-top:1rem;font-size:1rem;color:var(--secondary);font-weight:500;position:relative}.modern-button{display:inline-flex;align-items:center;padding:.75rem 1.5rem;background:linear-gradient(135deg,#3b82f6,#8b5cf6);color:#fff;text-decoration:none;border-radius:12px;font-weight:500;transition:all .3s ease;box-shadow:0 4px 12px rgba(59,130,246,.3);position:relative;overflow:hidden}.modern-button::before{content:"";position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent);transition:left .6s ease}.modern-button:hover::before{left:100%}.modern-button:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(59,130,246,.4)}@keyframes fadeInUp{from{opacity:0;transform:translateY(30px)}to{opacity:1;transform:translateY(0)}}.post-content>*{animation:fadeInUp .6s ease-out;animation-fill-mode:both}.post-content>*:nth-child(1){animation-delay:.1s}.post-content>*:nth-child(2){animation-delay:.2s}.post-content>*:nth-child(3){animation-delay:.3s}.post-content>*:nth-child(4){animation-delay:.4s}@media(max-width:768px){.promotion-section{margin:2rem -1rem;border-radius:0;padding:1.5rem 1rem}.qr-codes{flex-direction:column;align-items:center;gap:1.5rem}.qr-item img{width:140px;height:140px;padding:10px}.promotion-section h3{font-size:1.25rem}}.reading-progress{position:fixed;top:0;left:0;width:0%;height:3px;background:linear-gradient(90deg,#3b82f6,#8b5cf6,#06b6d4);z-index:999;transition:width .1s ease}.post-actions{margin-top:2.5rem;padding-top:1.25rem;border-top:1px dashed var(--border)}.post-actions__group{display:flex;flex-wrap:wrap;gap:.75rem 1rem;align-items:center}.post-actions__item{display:inline-flex;align-items:center}*{transition:background-color .3s ease,color .3s ease,border-color .3s ease}::-webkit-scrollbar{width:8px}::-webkit-scrollbar-track{background:var(--theme)}::-webkit-scrollbar-thumb{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-radius:4px}::-webkit-scrollbar-thumb:hover{background:linear-gradient(135deg,#2563eb,#7c3aed)}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=document.createElement("div");e.className="reading-progress",document.body.appendChild(e);function t(){const t=document.documentElement.scrollTop||document.body.scrollTop,n=document.documentElement.scrollHeight-document.documentElement.clientHeight,s=t/n*100;e.style.width=s+"%"}window.addEventListener("scroll",t),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();const t=document.querySelector(this.getAttribute("href"));t&&t.scrollIntoView({behavior:"smooth",block:"start"})})})})</script><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-K6VQRF8T")</script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K6VQRF8T" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-62VF26DEY6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-62VF26DEY6")</script><meta property="og:url" content="https://rexai.top/en/tutorials/rust/tokio-spawn-is-not-a-thread/"><meta property="og:site_name" content="梦兽编程"><meta property="og:title" content="Stop treating tokio::spawn as a thread! I launched 1000 tasks in 2 seconds and the system stayed calm"><meta property="og:description" content="tokio::spawn is not a thread but a lightweight task. Under Tokio's scheduler you build highly concurrent services with sleep, timeout and select — 1000 tasks in 2 seconds with negligible overhead."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2025-08-11T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-11T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Tokio"><meta property="article:tag" content="Async"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Tokio::select!"><meta property="article:tag" content="Tokio::timeout"><meta property="og:image" content="https://rexai.top/en/tutorials/rust/tokio-spawn-is-not-a-thread/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rexai.top/en/tutorials/rust/tokio-spawn-is-not-a-thread/cover.png"><meta name=twitter:title content="Stop treating tokio::spawn as a thread! I launched 1000 tasks in 2 seconds and the system stayed calm"><meta name=twitter:description content="tokio::spawn is not a thread but a lightweight task. Under Tokio's scheduler you build highly concurrent services with sleep, timeout and select — 1000 tasks in 2 seconds with negligible overhead."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://rexai.top/en/tutorials/"},{"@type":"ListItem","position":2,"name":"Stop treating tokio::spawn as a thread! I launched 1000 tasks in 2 seconds and the system stayed calm","item":"https://rexai.top/en/tutorials/rust/tokio-spawn-is-not-a-thread/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Stop treating tokio::spawn as a thread! I launched 1000 tasks in 2 seconds and the system stayed calm","name":"Stop treating tokio::spawn as a thread! I launched 1000 tasks in 2 seconds and the system stayed calm","description":"tokio::spawn is not a thread but a lightweight task. Under Tokio's scheduler you build highly concurrent services with sleep, timeout and select — 1000 tasks in 2 seconds with negligible overhead.","keywords":["Rust","Tokio","async","coroutines","concurrency","tokio::spawn","task scheduler","backend"],"articleBody":"Follow Rexai Programming on WeChat to learn Rust the easy way.\nForget the heavy “thread” mental model from your OS class. Today, I’ll show you a delightful trick about Tokio.\nYou think tokio::spawn creates a thread?\nNope. It gives you something smarter, lighter, and frankly a little sneaky: the ability to harness massive concurrency at a shockingly low cost. This is one of Rust’s secret weapons in backend development.\nReady? Let’s reveal the trick.\nThe core trick: tokio::spawn is not a thread, it’s a task card Imagine you run a super popular restaurant.\nIn the old mental model (some Java/C++ era designs), every customer (a request) gets a dedicated chef (an OS thread) serving them from start to finish. When 1000 customers arrive at rush hour, you need 1000 chefs. The kitchen explodes—and so does your payroll.\nThat’s the thread dilemma: expensive and scarce.\nTokio is like a genius restaurant manager. It says: “I only have a small team of elite chefs (a small thread pool), but I can handle thousands of orders at once.”\nHow? With tokio::spawn.\nEach spawn is like sending a “task card” to the front desk. This card goes into a central scheduling system called the async runtime.\nuse tokio::task; #[tokio::main] async fn main() { let handle = task::spawn(async { println!(\"👨‍🍳 Background task: chopping like crazy...\"); // Simulate some work \"A plate of sliced cucumber\" }); let result = handle.await.unwrap(); println!(\"✅ Main thread: received -\u003e {result}\"); } That async block is the task card. After you spawn it, it doesn’t monopolize a chef (thread). It’s suspended and quietly queued, waiting for the manager to schedule it. The manager uses whatever idle moments the chefs have to execute instructions from those task cards.\nThe key: tasks are cooperative. They share a few threads under Tokio’s scheduler instead of owning one. This is what people call “green threads” or coroutines.\nThe art of not blocking: tokio::time::sleep Now, a task card says: “Wait 5 minutes for the oven to preheat.”\nA naive chef (std::thread::sleep) would stare at the oven and do nothing, wasting 5 minutes. The thread is completely blocked and can’t do anything else.\nA Tokio chef (tokio::time::sleep) is different. They flip the oven on and immediately tell the manager: “Oven is preheating, ping me in 5 minutes.” Then they move on to other tasks like washing veggies.\nuse tokio::time::{sleep, Duration}; #[tokio::main] async fn main() { println!(\"⏳ Waiting...\"); // Non-blocking sleep: yield control back to the scheduler sleep(Duration::from_secs(2)).await; println!(\"⏰ Time's up, back to work!\"); } sleep doesn’t freeze the thread. It pauses the current task and lets the CPU handle hundreds or thousands of other tasks. That’s how you build highly responsive apps.\nDeadlines matter: tokio::time::timeout Customers are getting impatient! The manager must set deadlines.\ntimeout is like strapping an alarm clock on a slow operation. If it doesn’t finish in time, bail and move on to a fallback.\nuse tokio::time::{timeout, Duration, sleep}; async fn slow_task() { // This task needs 5 seconds sleep(Duration::from_secs(5)).await; } #[tokio::main] async fn main() { // You only get 2 seconds! let result = timeout(Duration::from_secs(2), slow_task()).await; match result { Ok(_) =\u003e println!(\"✅ Finished on time\"), Err(_) =\u003e println!(\"❌ Timed out!\"), } } This is a lifesaver for networked services. A slow DB query or third‑party API won’t drag your entire service down.\nFirst responder wins: the tokio::select! macro The manager has two urgent tasks: A needs data from the database, B from the cache. Whichever returns first wins.\nselect! is a race. It waits on multiple async operations simultaneously; as soon as any finishes, it returns that result and cancels the slower ones.\nuse tokio::time::{sleep, Duration}; #[tokio::main] async fn main() { tokio::select! { _ = sleep(Duration::from_secs(2)) =\u003e println!(\"😴 Task 1 (the slow one) finished\"), _ = sleep(Duration::from_secs(1)) =\u003e println!(\"🚀 Task 2 (the fast one) won!\"), } } It’s more than a race—it’s a powerful control‑flow tool. For example, you can listen for inbound requests while also listening for a shutdown signal. Whichever happens first, your program responds immediately.\nThe showdown: launch 1000 tasks Remember the nightmare of hiring 1000 chefs? With Tokio it’s trivial:\nuse tokio::time::{sleep, Duration}; #[tokio::main] async fn main() { let mut handles = vec![]; // Create 1000 concurrent tasks effortlessly within ~2 seconds for i in 0..1000 { let handle = tokio::spawn(async move { // Each task sleeps a tiny bit sleep(Duration::from_millis(10)).await; // println!(\"Task {i} ✅\"); // Commented to avoid spam }); handles.push(handle); } // Wait for all tasks to complete for handle in handles { handle.await.unwrap(); } println!(\"🎉 All 1000 tasks completed; the system stayed calm!\"); } On a regular laptop, this finishes almost instantly. No heavy thread creation/destruction, no excessive memory usage—just smooth task scheduling.\nThat’s the truth behind the “Tokio trick”: feather‑light tasks replacing heavy OS threads, letting you achieve massive concurrency at minimal cost.\nNow you’re the genius manager who can run a 10,000‑order kitchen.\nFollow Rexai Programming on WeChat for more deep‑dive content.\n","wordCount":"818","inLanguage":"en","image":"https://rexai.top/en/tutorials/rust/tokio-spawn-is-not-a-thread/cover.png","datePublished":"2025-08-11T00:00:00Z","dateModified":"2025-08-11T00:00:00Z","author":{"@type":"Person","name":"Rexai Programming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rexai.top/en/tutorials/rust/tokio-spawn-is-not-a-thread/"},"publisher":{"@type":"Organization","name":"梦兽编程","logo":{"@type":"ImageObject","url":"https://rexai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rexai.top/en/ accesskey=h title="梦兽编程 (Alt + H)">梦兽编程</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://rexai.top/ title=中文 aria-label=中文>Zh-Cn</a></li></ul></div></div><button class=menu-toggle id=menu-toggle aria-label=打开菜单 aria-controls=menu aria-expanded=false>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul id=menu role=menubar><li role=none><a href=https://rexai.top/en/ title=Home role=menuitem><span>Home</span></a></li><li class=has-submenu role=none><a href=https://rexai.top/en/tutorials/ title="📚 Tutorials" role=menuitem><span>📚 Tutorials</span>
<span class=submenu-toggle role=button tabindex=0 aria-expanded=false aria-haspopup=true>▼</span></a><ul class=submenu role=menu><li role=none><a href=https://rexai.top/en/tutorials/rust/ title=Rust role=menuitem>Rust</a></li><li role=none><a href=https://rexai.top/en/tutorials/ai/ title="AI Programming" role=menuitem>AI Programming</a></li></ul></li><li role=none><a href=https://rexai.top/en/tools/ title=Tools role=menuitem><span>Tools</span></a></li><li role=none><a href=https://rexai.top/en/news/ title="🔥 News" role=menuitem><span>🔥 News</span></a></li><li role=none><a href=https://rexai.top/en/tags/ title="🏷️ Tags" role=menuitem><span>🏷️ Tags</span></a></li><li role=none><a href=https://rexai.top/en/categories/ title="📂 Categories" role=menuitem><span>📂 Categories</span></a></li></ul><div id=menu-overlay class=menu-overlay hidden></div></nav></header><style>.has-submenu{position:relative}#menu{overflow:visible !important}#menu li{overflow:visible}.submenu{position:absolute;top:100%;left:0;background:var(--theme);border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);min-width:180px;z-index:1000;list-style:none;display:none;padding:.5rem 0}.submenu li{display:block;margin:0;line-height:1.5}#menu .submenu li+li{margin-inline-start:0}.submenu a{display:block;padding:.75rem 1rem;color:var(--secondary);text-decoration:none;transition:all .2s ease;border-radius:0}.submenu a:hover{background:var(--entry);color:var(--primary)}.has-submenu:hover .submenu{display:block !important}.submenu-toggle{margin-left:.25rem;font-size:.75rem;transition:transform .2s ease;display:inline-block}.has-submenu:hover .submenu-toggle{transform:rotate(180deg)}@media(max-width:768px){.menu-toggle{display:inline-flex;align-items:center;justify-content:center;width:44px;height:44px;margin-inline-end:var(--gap);border-radius:8px;border:1px solid var(--border);background:var(--theme);color:var(--primary)}#menu{position:fixed;top:0;right:0;height:100vh;width:82vw;max-width:340px;background:var(--theme);box-shadow:-2px 0 20px rgba(0,0,0,.18);transform:translateX(100%);transition:transform .25s ease;padding:calc(var(--header-height) + 10px)16px 20px;flex-direction:column;gap:4px;overflow-y:auto !important;z-index:1001}body.menu-open #menu{transform:translateX(0)}.menu-overlay{position:fixed;inset:0;background:rgba(0,0,0,.4);opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:1000}body.menu-open .menu-overlay{opacity:1;pointer-events:auto}#menu li+li{margin-inline-start:0}#menu a{padding:12px 8px}.submenu{position:static;box-shadow:none;border:none;background:var(--entry);margin-top:0;margin-left:1rem;display:block;max-height:0;overflow:hidden;padding:0;transition:max-height .25s ease,padding .2s ease}.has-submenu.active .submenu{max-height:1000px;padding:4px 0 6px}.submenu-toggle{cursor:pointer}.has-submenu.active>a .submenu-toggle{transform:rotate(180deg)}}@media(min-width:769px){.menu-toggle{display:none}}.submenu a:focus-visible,#menu a:focus-visible,.menu-toggle:focus-visible,.submenu-toggle:focus-visible{outline:2px solid var(--primary);outline-offset:2px;border-radius:6px}@media(max-width:768px){#menu a.is-current,#menu a.is-current>span{border-bottom:none !important;background:var(--entry);color:var(--primary);border-radius:8px;font-weight:600}#menu a.is-current{padding:10px}#menu a{width:100%;border-radius:8px}#menu .active{border-bottom:none !important}}body.menu-open{overflow:hidden;touch-action:none}</style><script>(function(){const s=document.getElementById("menu"),t=document.getElementById("menu-toggle"),o=document.getElementById("menu-overlay");if(!s||!t||!o)return;const i=()=>window.innerWidth<=768,r=()=>{document.body.classList.add("menu-open"),t.setAttribute("aria-expanded","true"),o.hidden=!1,l()},n=()=>{document.body.classList.remove("menu-open"),t.setAttribute("aria-expanded","false"),o.hidden=!0,d(),t.focus()};t.addEventListener("click",()=>{const e=document.body.classList.contains("menu-open");e?n():r()}),o.addEventListener("click",n),window.addEventListener("keydown",e=>{e.key==="Escape"&&n()}),window.addEventListener("resize",()=>{window.innerWidth>768&&n()});const c=()=>{const e=Array.from(document.querySelectorAll(".has-submenu")),t=t=>{e.forEach(e=>{if(e!==t&&e.classList.contains("active")){e.classList.remove("active");const t=e.querySelector(".submenu-toggle");t&&t.setAttribute("aria-expanded","false")}})};e.forEach(e=>{const o=e.querySelector("a"),n=e.querySelector(".submenu-toggle"),a=e.querySelector(".submenu");if(!n||!a||!o)return;const r=t=>{n.setAttribute("aria-expanded",t?"true":"false"),e.classList.toggle("active",t)},s=()=>{const n=!e.classList.contains("active");n&&t(e),r(n)};n.addEventListener("click",e=>{if(!i())return;e.preventDefault(),e.stopPropagation(),s()}),n.addEventListener("keydown",e=>{if(!i())return;(e.key==="Enter"||e.key===" ")&&(e.preventDefault(),e.stopPropagation(),s())}),o.addEventListener("click",e=>{if(!i())return;e.preventDefault(),e.stopPropagation(),s()})})};let e=[];const a=t=>{if(t.key!=="Tab"||!document.body.classList.contains("menu-open"))return;e=Array.from(s.querySelectorAll('a, button, [tabindex="0"]'));const n=e[0],o=e[e.length-1];if(!n||!o)return;t.shiftKey&&document.activeElement===n?(t.preventDefault(),o.focus()):!t.shiftKey&&document.activeElement===o&&(t.preventDefault(),n.focus())},l=()=>{e=Array.from(s.querySelectorAll('a, button, [tabindex="0"]')),e.length&&e[0].focus(),document.addEventListener("keydown",a)},d=()=>{document.removeEventListener("keydown",a)};c(),s.addEventListener("click",e=>{const t=e.target;if(!(t instanceof Element)||!i())return;const s=t.closest("a");if(!s)return;const o=s.closest("li"),a=o&&o.classList.contains("has-submenu");a||n()})})()</script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Stop treating tokio::spawn as a thread! I launched 1000 tasks in 2 seconds and the system stayed calm</h1><div class=post-description>tokio::spawn is not a thread but a lightweight task. Under Tokio's scheduler you build highly concurrent services with sleep, timeout and select — 1000 tasks in 2 seconds with negligible overhead.</div><div class=post-meta><span title='2025-08-11 00:00:00 +0000 UTC'>August 11, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;818 words&nbsp;·&nbsp;Rexai Programming&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/>Zh-Cn</a></li></ul></div></header><figure class=entry-cover><img loading=eager srcset='https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/cover_hu_4ca04fa6d59eeb4e.png 360w,https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/cover_hu_2d1f5b0af405e2b7.png 480w,https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/cover_hu_3d12831de639316.png 720w,https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/cover_hu_b4e92d26697bdc2b.png 1080w,https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/cover_hu_cc55d97afa2c5f32.png 1500w,https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/cover.png 1536w' src=https://rexai.top/tutorials/rust/tokio-spawn-is-not-a-thread/cover.png sizes="(min-width: 768px) 720px, 100vw" width=1536 height=1024 alt="The difference between Tokio tasks and OS threads"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-core-trick-tokiospawn-is-not-a-thread-its-a-task-card aria-label="The core trick: tokio::spawn is not a thread, it’s a task card">The core trick: tokio::spawn is not a thread, it’s a task card</a></li><li><a href=#the-art-of-not-blocking-tokiotimesleep aria-label="The art of not blocking: tokio::time::sleep">The art of not blocking: tokio::time::sleep</a></li><li><a href=#deadlines-matter-tokiotimetimeout aria-label="Deadlines matter: tokio::time::timeout">Deadlines matter: tokio::time::timeout</a></li><li><a href=#first-responder-wins-the-tokioselect-macro aria-label="First responder wins: the tokio::select! macro">First responder wins: the tokio::select! macro</a></li><li><a href=#the-showdown-launch-1000-tasks aria-label="The showdown: launch 1000 tasks">The showdown: launch 1000 tasks</a></li></ul></div></details></div><div class=post-content><p>Follow Rexai Programming on WeChat to learn Rust the easy way.</p><p>Forget the heavy &ldquo;thread&rdquo; mental model from your OS class. Today, I’ll show you a delightful trick about Tokio.</p><p>You think <code>tokio::spawn</code> creates a thread?</p><p>Nope. It gives you something smarter, lighter, and frankly a little sneaky: the ability to harness massive concurrency at a shockingly low cost. This is one of Rust’s secret weapons in backend development.</p><p>Ready? Let’s reveal the trick.</p><h2 id=the-core-trick-tokiospawn-is-not-a-thread-its-a-task-card>The core trick: tokio::spawn is not a thread, it’s a task card<a hidden class=anchor aria-hidden=true href=#the-core-trick-tokiospawn-is-not-a-thread-its-a-task-card>#</a></h2><p>Imagine you run a super popular restaurant.</p><p>In the old mental model (some Java/C++ era designs), every customer (a request) gets a dedicated chef (an OS thread) serving them from start to finish. When 1000 customers arrive at rush hour, you need 1000 chefs. The kitchen explodes—and so does your payroll.</p><p>That’s the thread dilemma: expensive and scarce.</p><p>Tokio is like a genius restaurant manager. It says: “I only have a small team of elite chefs (a small thread pool), but I can handle thousands of orders at once.”</p><p>How? With <code>tokio::spawn</code>.</p><p>Each <code>spawn</code> is like sending a &ldquo;task card&rdquo; to the front desk. This card goes into a central scheduling system called the async runtime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::task;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> task::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;👨‍🍳 Background task: chopping like crazy...&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Simulate some work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>&#34;A plate of sliced cucumber&#34;</span>
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> handle.<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;✅ Main thread: received -&gt; </span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That <code>async</code> block is the task card. After you <code>spawn</code> it, it doesn’t monopolize a chef (thread). It’s suspended and quietly queued, waiting for the manager to schedule it. The manager uses whatever idle moments the chefs have to execute instructions from those task cards.</p><p>The key: tasks are cooperative. They share a few threads under Tokio’s scheduler instead of owning one. This is what people call &ldquo;green threads&rdquo; or coroutines.</p><h2 id=the-art-of-not-blocking-tokiotimesleep>The art of not blocking: <code>tokio::time::sleep</code><a hidden class=anchor aria-hidden=true href=#the-art-of-not-blocking-tokiotimesleep>#</a></h2><p>Now, a task card says: “Wait 5 minutes for the oven to preheat.”</p><p>A naive chef (<code>std::thread::sleep</code>) would stare at the oven and do nothing, wasting 5 minutes. The thread is completely blocked and can’t do anything else.</p><p>A Tokio chef (<code>tokio::time::sleep</code>) is different. They flip the oven on and immediately tell the manager: “Oven is preheating, ping me in 5 minutes.” Then they move on to other tasks like washing veggies.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::time::{sleep, Duration};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;⏳ Waiting...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Non-blocking sleep: yield control back to the scheduler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sleep(Duration::from_secs(<span style=color:#ae81ff>2</span>)).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;⏰ Time&#39;s up, back to work!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>sleep</code> doesn’t freeze the thread. It pauses the current task and lets the CPU handle hundreds or thousands of other tasks. That’s how you build highly responsive apps.</p><h2 id=deadlines-matter-tokiotimetimeout>Deadlines matter: <code>tokio::time::timeout</code><a hidden class=anchor aria-hidden=true href=#deadlines-matter-tokiotimetimeout>#</a></h2><p>Customers are getting impatient! The manager must set deadlines.</p><p><code>timeout</code> is like strapping an alarm clock on a slow operation. If it doesn’t finish in time, bail and move on to a fallback.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::time::{timeout, Duration, sleep};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>slow_task</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This task needs 5 seconds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sleep(Duration::from_secs(<span style=color:#ae81ff>5</span>)).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// You only get 2 seconds!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> timeout(Duration::from_secs(<span style=color:#ae81ff>2</span>), slow_task()).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> result {
</span></span><span style=display:flex><span>        Ok(_) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;✅ Finished on time&#34;</span>),
</span></span><span style=display:flex><span>        Err(_) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;❌ Timed out!&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a lifesaver for networked services. A slow DB query or third‑party API won’t drag your entire service down.</p><h2 id=first-responder-wins-the-tokioselect-macro>First responder wins: the <code>tokio::select!</code> macro<a hidden class=anchor aria-hidden=true href=#first-responder-wins-the-tokioselect-macro>#</a></h2><p>The manager has two urgent tasks: A needs data from the database, B from the cache. Whichever returns first wins.</p><p><code>select!</code> is a race. It waits on multiple async operations simultaneously; as soon as any finishes, it returns that result and cancels the slower ones.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::time::{sleep, Duration};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    tokio::<span style=color:#a6e22e>select!</span> {
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=</span> sleep(Duration::from_secs(<span style=color:#ae81ff>2</span>)) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;😴 Task 1 (the slow one) finished&#34;</span>),
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=</span> sleep(Duration::from_secs(<span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;🚀 Task 2 (the fast one) won!&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It’s more than a race—it’s a powerful control‑flow tool. For example, you can listen for inbound requests while also listening for a shutdown signal. Whichever happens first, your program responds immediately.</p><h2 id=the-showdown-launch-1000-tasks>The showdown: launch 1000 tasks<a hidden class=anchor aria-hidden=true href=#the-showdown-launch-1000-tasks>#</a></h2><p>Remember the nightmare of hiring 1000 chefs? With Tokio it’s trivial:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::time::{sleep, Duration};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> handles <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create 1000 concurrent tasks effortlessly within ~2 seconds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>1000</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Each task sleeps a tiny bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            sleep(Duration::from_millis(<span style=color:#ae81ff>10</span>)).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// println!(&#34;Task {i} ✅&#34;); // Commented to avoid spam
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        });
</span></span><span style=display:flex><span>        handles.push(handle);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wait for all tasks to complete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> handle <span style=color:#66d9ef>in</span> handles {
</span></span><span style=display:flex><span>        handle.<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;🎉 All 1000 tasks completed; the system stayed calm!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On a regular laptop, this finishes almost instantly. No heavy thread creation/destruction, no excessive memory usage—just smooth task scheduling.</p><p>That’s the truth behind the &ldquo;Tokio trick&rdquo;: feather‑light tasks replacing heavy OS threads, letting you achieve massive concurrency at minimal cost.</p><p>Now you’re the genius manager who can run a 10,000‑order kitchen.</p><hr><p>Follow Rexai Programming on WeChat for more deep‑dive content.</p></div><section class=post-actions aria-label="post actions"><div class=post-actions__group><div class=post-actions__item><script type=text/javascript src=https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js data-name=bmc-button data-slug=winbbryz data-color=#FFDD00 data-emoji data-font=Cookie data-text="Buy me a coffee" data-outline-color=#000000 data-font-color=#000000 data-coffee-color=#ffffff></script></div></div></section><footer class=post-footer><ul class=post-tags><li><a href=https://rexai.top/en/tags/rust/>Rust</a></li><li><a href=https://rexai.top/en/tags/tokio/>Tokio</a></li><li><a href=https://rexai.top/en/tags/async/>Async</a></li><li><a href=https://rexai.top/en/tags/concurrency/>Concurrency</a></li><li><a href=https://rexai.top/en/tags/tokioselect/>Tokio::select!</a></li><li><a href=https://rexai.top/en/tags/tokiotimeout/>Tokio::timeout</a></li><li><a href=https://rexai.top/en/tags/tokiotimesleep/>Tokio::time::sleep</a></li></ul></footer></article></main><footer class=footer><span>© <a href=https://rexai.top/>梦兽编程</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>