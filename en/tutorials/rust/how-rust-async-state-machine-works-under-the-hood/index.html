<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust Async State Machine, Unmasked: How Future, poll, and Waker Really Work | Ê¢¶ÂÖΩÁºñÁ®ã</title><meta name=keywords content="Rust,async,await,Future,Tokio,executor,state machine,Waker,poll,task scheduling,zero-cost abstraction,Rust tutorial"><meta name=description content="A practical deep dive into Rust async: why calling an async function doesn't run it, how the compiler turns async into a state machine, and how executors drive tasks forward with poll and Waker. Understand the real mechanics behind async/await."><meta name=author content="Rexai Programming"><link rel=canonical href=https://rexai.top/en/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/><link crossorigin=anonymous href=/assets/css/stylesheet.e5b4b51f610424d950e0e577f9c4ebc278c695a3ed14413258df4f4abc839fa1.css integrity="sha256-5bS1H2EEJNlQ4OV3+cTrwnjGlaPtFEEyWN9PSryDn6E=" rel="preload stylesheet" as=style><link rel=icon href=https://rexai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rexai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rexai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://rexai.top/apple-touch-icon.png><link rel=mask-icon href=https://rexai.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/><link rel=alternate hreflang=en href=https://rexai.top/en/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/extended/modern-typography.min.css integrity><style>.promotion-section{margin-top:3rem;padding:2rem;text-align:center;background:linear-gradient(135deg,rgba(59,130,246,5%) 0%,rgba(139,92,246,5%) 100%);border-radius:16px;border:1px solid rgba(59,130,246,.1);position:relative;overflow:hidden}.promotion-section::before{content:"";position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#3b82f6,#8b5cf6,#06b6d4);border-radius:16px 16px 0 0}.promotion-section h3{margin-bottom:1.5rem;color:var(--primary);font-size:1.5rem;font-weight:600;background:linear-gradient(135deg,#3b82f6,#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.qr-codes{display:flex;gap:2.5rem;justify-content:center;flex-wrap:wrap;margin-top:2rem}.qr-item{text-align:center;position:relative;transition:transform .3s ease}.qr-item:hover{transform:translateY(-5px)}.qr-item img{width:160px;height:160px;border:2px solid #e5e7eb;border-radius:16px;padding:12px;background:#fff;box-shadow:0 4px 20px rgba(0,0,0,8%),0 1px 3px rgba(0,0,0,.1);transition:all .3s ease;position:relative;overflow:hidden}.qr-item img::before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,rgba(59,130,246,.1),rgba(139,92,246,.1));opacity:0;transition:opacity .3s ease;z-index:1}.qr-item:hover img{border-color:#3b82f6;box-shadow:0 8px 30px rgba(59,130,246,.2),0 2px 8px rgba(0,0,0,.1);transform:scale(1.02)}.qr-item:hover img::before{opacity:1}.qr-item p{margin-top:1rem;font-size:1rem;color:var(--secondary);font-weight:500;position:relative}.modern-button{display:inline-flex;align-items:center;padding:.75rem 1.5rem;background:linear-gradient(135deg,#3b82f6,#8b5cf6);color:#fff;text-decoration:none;border-radius:12px;font-weight:500;transition:all .3s ease;box-shadow:0 4px 12px rgba(59,130,246,.3);position:relative;overflow:hidden}.modern-button::before{content:"";position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent);transition:left .6s ease}.modern-button:hover::before{left:100%}.modern-button:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(59,130,246,.4)}@keyframes fadeInUp{from{opacity:0;transform:translateY(30px)}to{opacity:1;transform:translateY(0)}}.post-content>*{animation:fadeInUp .6s ease-out;animation-fill-mode:both}.post-content>*:nth-child(1){animation-delay:.1s}.post-content>*:nth-child(2){animation-delay:.2s}.post-content>*:nth-child(3){animation-delay:.3s}.post-content>*:nth-child(4){animation-delay:.4s}@media(max-width:768px){.promotion-section{margin:2rem -1rem;border-radius:0;padding:1.5rem 1rem}.qr-codes{flex-direction:column;align-items:center;gap:1.5rem}.qr-item img{width:140px;height:140px;padding:10px}.promotion-section h3{font-size:1.25rem}}.reading-progress{position:fixed;top:0;left:0;width:0%;height:3px;background:linear-gradient(90deg,#3b82f6,#8b5cf6,#06b6d4);z-index:999;transition:width .1s ease}.post-actions{margin-top:2.5rem;padding-top:1.25rem;border-top:1px dashed var(--border)}.post-actions__group{display:flex;flex-wrap:wrap;gap:.75rem 1rem;align-items:center}.post-actions__item{display:inline-flex;align-items:center}*{transition:background-color .3s ease,color .3s ease,border-color .3s ease}::-webkit-scrollbar{width:8px}::-webkit-scrollbar-track{background:var(--theme)}::-webkit-scrollbar-thumb{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-radius:4px}::-webkit-scrollbar-thumb:hover{background:linear-gradient(135deg,#2563eb,#7c3aed)}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=document.createElement("div");e.className="reading-progress",document.body.appendChild(e);function t(){const t=document.documentElement.scrollTop||document.body.scrollTop,n=document.documentElement.scrollHeight-document.documentElement.clientHeight,s=t/n*100;e.style.width=s+"%"}window.addEventListener("scroll",t),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();const t=document.querySelector(this.getAttribute("href"));t&&t.scrollIntoView({behavior:"smooth",block:"start"})})})})</script><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-K6VQRF8T")</script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K6VQRF8T" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-62VF26DEY6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-62VF26DEY6")</script><meta property="og:url" content="https://rexai.top/en/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/"><meta property="og:site_name" content="Ê¢¶ÂÖΩÁºñÁ®ã"><meta property="og:title" content="Rust Async State Machine, Unmasked: How Future, poll, and Waker Really Work"><meta property="og:description" content="A practical deep dive into Rust async: why calling an async function doesn't run it, how the compiler turns async into a state machine, and how executors drive tasks forward with poll and Waker. Understand the real mechanics behind async/await."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2025-08-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-10T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta property="article:tag" content="Future"><meta property="article:tag" content="Tokio"><meta property="article:tag" content="Concurrency"><meta property="og:image" content="https://rexai.top/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rexai.top/cover.png"><meta name=twitter:title content="Rust Async State Machine, Unmasked: How Future, poll, and Waker Really Work"><meta name=twitter:description content="A practical deep dive into Rust async: why calling an async function doesn't run it, how the compiler turns async into a state machine, and how executors drive tasks forward with poll and Waker. Understand the real mechanics behind async/await."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://rexai.top/en/tutorials/"},{"@type":"ListItem","position":2,"name":"Rust Async State Machine, Unmasked: How Future, poll, and Waker Really Work","item":"https://rexai.top/en/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Async State Machine, Unmasked: How Future, poll, and Waker Really Work","name":"Rust Async State Machine, Unmasked: How Future, poll, and Waker Really Work","description":"A practical deep dive into Rust async: why calling an async function doesn't run it, how the compiler turns async into a state machine, and how executors drive tasks forward with poll and Waker. Understand the real mechanics behind async/await.","keywords":["Rust","async","await","Future","Tokio","executor","state machine","Waker","poll","task scheduling","zero-cost abstraction","Rust tutorial"],"articleBody":"Your Rust async code is a ‚Äúliar‚Äù‚Äîand I‚Äôm going to strip its state machine down to the bones.\nHave you ever written an async function, happily called it, and then‚Ä¶ the program just ended with nothing happening?\nYou stare at the screen: Where did my code go? Where‚Äôs my println!? Did I just run emptiness?\nDon‚Äôt panic. You‚Äôre not alone. Welcome to the world of Rust async, where the first rule is: what you see isn‚Äôt necessarily what‚Äôs happening.\nasync/await is Rust‚Äôs concurrency ace. It lets you write non-blocking, high-performance programs with code that looks synchronous, handling thousands of connections with ease. But behind the elegant sugar lies a precise mechanism that confuses many newcomers.\nToday, we‚Äôll go into Rust‚Äôs engine room and make Future, .poll(), and the state machine crystal clear.\nAct 1: The big misunderstanding ‚Äî async fn does not run immediately Start with the most basic ‚Äútrick‚Äù. You write:\nasync fn say_hello() { println!(\"Hello, from the future!\"); } Then you call it:\nfn main() { say_hello(); // Program exits; nothing is printed } Why? Because calling an async function does not execute its body. It returns a value called a Future.\nWhat is a Future?\nThink of it as a ‚Äúvoucher‚Äù redeemable in the future.\nThe voucher itself does nothing. Holding it won‚Äôt magically produce a prize. say_hello() returns such a voucher that says: ‚ÄúI promise to print a line at some point in the future.‚Äù\nYour main gets the voucher and throws it away. The program ends.\nRemember: an async function returns a plan, not a result.\nAct 2: Ignition ‚Äî the executor and .await How do we redeem the voucher?\nYou need an executor, like tokio or async-std.\nThe executor is like a kitchen manager with infinite energy.\nYour Future (the voucher) is a set of recipes.\nWhen you hand recipes to the manager, work actually begins. In code, this handoff is often handled by the #[tokio::main] macro or a manual block_on.\n#[tokio::main] async fn main() { say_hello().await; // This time, it prints! } Notice the magical .await. It‚Äôs the ignition switch.\nWhat does .await do? It tells the kitchen manager (executor):\n‚ÄúHey, I‚Äôm starting say_hello. If it needs time (like preheating an oven), don‚Äôt just wait there. Go do other things. When I‚Äôm ready, I‚Äôll notify you.‚Äù\nThis is the core of async/await: non-blocking. .await is the point where a task can pause and yield control.\nAct 3: Under the hood ‚Äî Future is a state machine Now the final reveal. When the compiler sees your async fn, it secretly transforms it into a struct that implements the Future trait.\nThat struct is a small state machine.\nConsider a slightly more complex example:\nasync fn cook_meal() { println!(\"Start washing vegetables...\"); let ingredients = chop_vegetables().await; // first suspension point println!(\"Chopping done, start frying...\"); let dish = fry_in_pan(ingredients).await; // second suspension point println!(\"Serve!\"); } The compiler turns it into a state machine roughly like this:\nState 0: initial State 1: chopping (waiting for chop_vegetables) State 2: frying (waiting for fry_in_pan) State 3: done The executor repeatedly asks the state machine one question via .poll(): ‚ÄúAre you done yet?‚Äù\n.poll() can return:\nPoll::Ready(result): Done! Here‚Äôs the result. Poll::Pending: Not ready. I‚Äôm waiting for something (network, timer). Go do other work. I‚Äôll use a Waker to notify you when to come back. The flow looks like this:\nManager polls cook_meal. Code runs println!(\"Start washing vegetables...\"). Hits chop_vegetables().await, manager starts polling the chopping task. Chopping takes time ‚Üí returns Pending. Manager shelves cook_meal and handles other recipes. Later, an external event (I/O, timer) fires and uses the Waker to wake cook_meal. Manager polls again; it resumes from where it paused and gets the chopped ingredients. Hits fry_in_pan().await; repeat. Eventually, .poll() returns Ready; task completes. No magic. Just a precise state machine driven by poll and Waker. Your async code runs in small pieces, cooperatively scheduled.\nRecap: Putting the elephant in the fridge Concept Plain analogy Purpose async fn a recipe Defines a task to run later; doesn‚Äôt run itself. Future voucher + progress tracker The state machine that records where execution is. Executor (e.g., Tokio) tireless kitchen manager Schedules/advances many futures to keep the kitchen busy. .await ‚Äúwait, but don‚Äôt idle‚Äù Suspension point that yields control to the executor. .poll() ‚ÄúDone yet?‚Äù Advances the state machine one step. Waker timer/alarm Notifies the executor to poll again when ready. Next time your async code behaves counterintuitively, remember: it‚Äôs not lying. It‚Äôs faithfully following the kitchen workflow. Your job is to write good recipes and place .await at the right spots.\nFollow Rexai Programming on WeChat to unlock more dev magic.\n","wordCount":"770","inLanguage":"en","image":"https://rexai.top/cover.png","datePublished":"2025-08-10T00:00:00Z","dateModified":"2025-08-10T00:00:00Z","author":{"@type":"Person","name":"Rexai Programming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rexai.top/en/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/"},"publisher":{"@type":"Organization","name":"Ê¢¶ÂÖΩÁºñÁ®ã","logo":{"@type":"ImageObject","url":"https://rexai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rexai.top/en/ accesskey=h title="Ê¢¶ÂÖΩÁºñÁ®ã (Alt + H)">Ê¢¶ÂÖΩÁºñÁ®ã</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://rexai.top/ title=‰∏≠Êñá aria-label=‰∏≠Êñá>Zh-Cn</a></li></ul></div></div><button class=menu-toggle id=menu-toggle aria-label=ÊâìÂºÄËèúÂçï aria-controls=menu aria-expanded=false>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul id=menu role=menubar><li role=none><a href=https://rexai.top/en/ title=Home role=menuitem><span>Home</span></a></li><li class=has-submenu role=none><a href=https://rexai.top/en/tutorials/ title="üìö Tutorials" role=menuitem><span>üìö Tutorials</span>
<span class=submenu-toggle role=button tabindex=0 aria-expanded=false aria-haspopup=true>‚ñº</span></a><ul class=submenu role=menu><li role=none><a href=https://rexai.top/en/tutorials/rust/ title=Rust role=menuitem>Rust</a></li><li role=none><a href=https://rexai.top/en/tutorials/ai/ title="AI Programming" role=menuitem>AI Programming</a></li></ul></li><li role=none><a href=https://rexai.top/en/tools/ title=Tools role=menuitem><span>Tools</span></a></li><li role=none><a href=https://rexai.top/en/news/ title="üî• News" role=menuitem><span>üî• News</span></a></li><li role=none><a href=https://rexai.top/en/tags/ title="üè∑Ô∏è Tags" role=menuitem><span>üè∑Ô∏è Tags</span></a></li><li role=none><a href=https://rexai.top/en/categories/ title="üìÇ Categories" role=menuitem><span>üìÇ Categories</span></a></li></ul><div id=menu-overlay class=menu-overlay hidden></div></nav></header><style>.has-submenu{position:relative}#menu{overflow:visible !important}#menu li{overflow:visible}.submenu{position:absolute;top:100%;left:0;background:var(--theme);border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);min-width:180px;z-index:1000;list-style:none;display:none;padding:.5rem 0}.submenu li{display:block;margin:0;line-height:1.5}#menu .submenu li+li{margin-inline-start:0}.submenu a{display:block;padding:.75rem 1rem;color:var(--secondary);text-decoration:none;transition:all .2s ease;border-radius:0}.submenu a:hover{background:var(--entry);color:var(--primary)}.has-submenu:hover .submenu{display:block !important}.submenu-toggle{margin-left:.25rem;font-size:.75rem;transition:transform .2s ease;display:inline-block}.has-submenu:hover .submenu-toggle{transform:rotate(180deg)}@media(max-width:768px){.menu-toggle{display:inline-flex;align-items:center;justify-content:center;width:44px;height:44px;margin-inline-end:var(--gap);border-radius:8px;border:1px solid var(--border);background:var(--theme);color:var(--primary)}#menu{position:fixed;top:0;right:0;height:100vh;width:82vw;max-width:340px;background:var(--theme);box-shadow:-2px 0 20px rgba(0,0,0,.18);transform:translateX(100%);transition:transform .25s ease;padding:calc(var(--header-height) + 10px)16px 20px;flex-direction:column;gap:4px;overflow-y:auto !important;z-index:1001}body.menu-open #menu{transform:translateX(0)}.menu-overlay{position:fixed;inset:0;background:rgba(0,0,0,.4);opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:1000}body.menu-open .menu-overlay{opacity:1;pointer-events:auto}#menu li+li{margin-inline-start:0}#menu a{padding:12px 8px}.submenu{position:static;box-shadow:none;border:none;background:var(--entry);margin-top:0;margin-left:1rem;display:block;max-height:0;overflow:hidden;padding:0;transition:max-height .25s ease,padding .2s ease}.has-submenu.active .submenu{max-height:1000px;padding:4px 0 6px}.submenu-toggle{cursor:pointer}.has-submenu.active>a .submenu-toggle{transform:rotate(180deg)}}@media(min-width:769px){.menu-toggle{display:none}}.submenu a:focus-visible,#menu a:focus-visible,.menu-toggle:focus-visible,.submenu-toggle:focus-visible{outline:2px solid var(--primary);outline-offset:2px;border-radius:6px}@media(max-width:768px){#menu a.is-current,#menu a.is-current>span{border-bottom:none !important;background:var(--entry);color:var(--primary);border-radius:8px;font-weight:600}#menu a.is-current{padding:10px}#menu a{width:100%;border-radius:8px}#menu .active{border-bottom:none !important}}body.menu-open{overflow:hidden;touch-action:none}</style><script>(function(){const s=document.getElementById("menu"),t=document.getElementById("menu-toggle"),o=document.getElementById("menu-overlay");if(!s||!t||!o)return;const i=()=>window.innerWidth<=768,r=()=>{document.body.classList.add("menu-open"),t.setAttribute("aria-expanded","true"),o.hidden=!1,l()},n=()=>{document.body.classList.remove("menu-open"),t.setAttribute("aria-expanded","false"),o.hidden=!0,d(),t.focus()};t.addEventListener("click",()=>{const e=document.body.classList.contains("menu-open");e?n():r()}),o.addEventListener("click",n),window.addEventListener("keydown",e=>{e.key==="Escape"&&n()}),window.addEventListener("resize",()=>{window.innerWidth>768&&n()});const c=()=>{const e=Array.from(document.querySelectorAll(".has-submenu")),t=t=>{e.forEach(e=>{if(e!==t&&e.classList.contains("active")){e.classList.remove("active");const t=e.querySelector(".submenu-toggle");t&&t.setAttribute("aria-expanded","false")}})};e.forEach(e=>{const o=e.querySelector("a"),n=e.querySelector(".submenu-toggle"),a=e.querySelector(".submenu");if(!n||!a||!o)return;const r=t=>{n.setAttribute("aria-expanded",t?"true":"false"),e.classList.toggle("active",t)},s=()=>{const n=!e.classList.contains("active");n&&t(e),r(n)};n.addEventListener("click",e=>{if(!i())return;e.preventDefault(),e.stopPropagation(),s()}),n.addEventListener("keydown",e=>{if(!i())return;(e.key==="Enter"||e.key===" ")&&(e.preventDefault(),e.stopPropagation(),s())}),o.addEventListener("click",e=>{if(!i())return;e.preventDefault(),e.stopPropagation(),s()})})};let e=[];const a=t=>{if(t.key!=="Tab"||!document.body.classList.contains("menu-open"))return;e=Array.from(s.querySelectorAll('a, button, [tabindex="0"]'));const n=e[0],o=e[e.length-1];if(!n||!o)return;t.shiftKey&&document.activeElement===n?(t.preventDefault(),o.focus()):!t.shiftKey&&document.activeElement===o&&(t.preventDefault(),n.focus())},l=()=>{e=Array.from(s.querySelectorAll('a, button, [tabindex="0"]')),e.length&&e[0].focus(),document.addEventListener("keydown",a)},d=()=>{document.removeEventListener("keydown",a)};c(),s.addEventListener("click",e=>{const t=e.target;if(!(t instanceof Element)||!i())return;const s=t.closest("a");if(!s)return;const o=s.closest("li"),a=o&&o.classList.contains("has-submenu");a||n()})})()</script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rust Async State Machine, Unmasked: How Future, poll, and Waker Really Work</h1><div class=post-description>A practical deep dive into Rust async: why calling an async function doesn't run it, how the compiler turns async into a state machine, and how executors drive tasks forward with poll and Waker. Understand the real mechanics behind async/await.</div><div class=post-meta><span title='2025-08-10 00:00:00 +0000 UTC'>August 10, 2025</span>&nbsp;¬∑&nbsp;4 min&nbsp;¬∑&nbsp;770 words&nbsp;¬∑&nbsp;Rexai Programming&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/>Zh-Cn</a></li></ul></div></header><figure class=entry-cover><img loading=eager srcset='https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/cover_hu_f6d679629eaee653.png 360w,https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/cover_hu_8d9b9c6fbe684659.png 480w,https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/cover_hu_dbdc6172d9157ee.png 720w,https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/cover_hu_b9b99fcf9d8591a0.png 1080w,https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/cover_hu_1cf182bb9b95ad8c.png 1500w,https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/cover.png 1536w' src=https://rexai.top/tutorials/rust/how-rust-async-state-machine-works-under-the-hood/cover.png sizes="(min-width: 768px) 720px, 100vw" width=1536 height=1024 alt="Rust async is compiled into a state machine and driven by Future, poll, and Waker"><figcaption>Under the hood, Rust async is a compiler-generated state machine</figcaption></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#act-1-the-big-misunderstanding--async-fn-does-not-run-immediately aria-label="Act 1: The big misunderstanding ‚Äî async fn does not run immediately">Act 1: The big misunderstanding ‚Äî async fn does not run immediately</a></li><li><a href=#act-2-ignition--the-executor-and-await aria-label="Act 2: Ignition ‚Äî the executor and .await">Act 2: Ignition ‚Äî the executor and .await</a></li><li><a href=#act-3-under-the-hood--future-is-a-state-machine aria-label="Act 3: Under the hood ‚Äî Future is a state machine">Act 3: Under the hood ‚Äî Future is a state machine</a></li><li><a href=#recap-putting-the-elephant-in-the-fridge aria-label="Recap: Putting the elephant in the fridge">Recap: Putting the elephant in the fridge</a></li></ul></div></details></div><div class=post-content><p>Your Rust <code>async</code> code is a &ldquo;liar&rdquo;‚Äîand I&rsquo;m going to strip its state machine down to the bones.</p><p>Have you ever written an <code>async</code> function, happily called it, and then&mldr; the program just ended with nothing happening?</p><p>You stare at the screen: Where did my code go? Where&rsquo;s my <code>println!</code>? Did I just run emptiness?</p><p>Don&rsquo;t panic. You&rsquo;re not alone. Welcome to the world of Rust <code>async</code>, where the first rule is: what you see isn&rsquo;t necessarily what&rsquo;s happening.</p><p><code>async/await</code> is Rust&rsquo;s concurrency ace. It lets you write non-blocking, high-performance programs with code that looks synchronous, handling thousands of connections with ease. But behind the elegant sugar lies a precise mechanism that confuses many newcomers.</p><p>Today, we&rsquo;ll go into Rust&rsquo;s engine room and make <code>Future</code>, <code>.poll()</code>, and the state machine crystal clear.</p><h2 id=act-1-the-big-misunderstanding--async-fn-does-not-run-immediately>Act 1: The big misunderstanding ‚Äî <code>async fn</code> does not run immediately<a hidden class=anchor aria-hidden=true href=#act-1-the-big-misunderstanding--async-fn-does-not-run-immediately>#</a></h2><p>Start with the most basic &ldquo;trick&rdquo;. You write:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>say_hello</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Hello, from the future!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then you call it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    say_hello();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Program exits; nothing is printed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Why? Because calling an <code>async</code> function does not execute its body. It returns a value called a <strong><code>Future</code></strong>.</p><p>What is a <code>Future</code>?</p><p>Think of it as a &ldquo;voucher&rdquo; redeemable in the future.</p><p>The voucher itself does nothing. Holding it won&rsquo;t magically produce a prize. <code>say_hello()</code> returns such a voucher that says: &ldquo;I promise to print a line at some point in the future.&rdquo;</p><p>Your <code>main</code> gets the voucher and throws it away. The program ends.</p><p>Remember: an <code>async</code> function returns a plan, not a result.</p><h2 id=act-2-ignition--the-executor-and-await>Act 2: Ignition ‚Äî the executor and <code>.await</code><a hidden class=anchor aria-hidden=true href=#act-2-ignition--the-executor-and-await>#</a></h2><p>How do we redeem the voucher?</p><p>You need an <strong>executor</strong>, like <code>tokio</code> or <code>async-std</code>.</p><p>The executor is like a kitchen manager with infinite energy.</p><p>Your <code>Future</code> (the voucher) is a set of recipes.</p><p>When you hand recipes to the manager, work actually begins. In code, this handoff is often handled by the <code>#[tokio::main]</code> macro or a manual <code>block_on</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    say_hello().<span style=color:#66d9ef>await</span>; <span style=color:#75715e>// This time, it prints!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Notice the magical <code>.await</code>. It&rsquo;s the ignition switch.</p><p>What does <code>.await</code> do? It tells the kitchen manager (executor):</p><blockquote><p>&ldquo;Hey, I&rsquo;m starting <code>say_hello</code>. If it needs time (like preheating an oven), don&rsquo;t just wait there. Go do other things. When I&rsquo;m ready, I&rsquo;ll notify you.&rdquo;</p></blockquote><p>This is the core of <code>async/await</code>: non-blocking. <code>.await</code> is the point where a task can pause and yield control.</p><h2 id=act-3-under-the-hood--future-is-a-state-machine>Act 3: Under the hood ‚Äî <code>Future</code> is a state machine<a hidden class=anchor aria-hidden=true href=#act-3-under-the-hood--future-is-a-state-machine>#</a></h2><p>Now the final reveal. When the compiler sees your <code>async fn</code>, it secretly transforms it into a struct that implements the <code>Future</code> trait.</p><p>That struct is a small <strong>state machine</strong>.</p><p>Consider a slightly more complex example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>cook_meal</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Start washing vegetables...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ingredients <span style=color:#f92672>=</span> chop_vegetables().<span style=color:#66d9ef>await</span>; <span style=color:#75715e>// first suspension point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Chopping done, start frying...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dish <span style=color:#f92672>=</span> fry_in_pan(ingredients).<span style=color:#66d9ef>await</span>; <span style=color:#75715e>// second suspension point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Serve!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The compiler turns it into a state machine roughly like this:</p><ul><li>State 0: initial</li><li>State 1: chopping (waiting for <code>chop_vegetables</code>)</li><li>State 2: frying (waiting for <code>fry_in_pan</code>)</li><li>State 3: done</li></ul><p>The executor repeatedly asks the state machine one question via <code>.poll()</code>: &ldquo;Are you done yet?&rdquo;</p><p><code>.poll()</code> can return:</p><ol><li><code>Poll::Ready(result)</code>: Done! Here&rsquo;s the result.</li><li><code>Poll::Pending</code>: Not ready. I&rsquo;m waiting for something (network, timer). Go do other work. I&rsquo;ll use a <code>Waker</code> to notify you when to come back.</li></ol><p>The flow looks like this:</p><ol><li>Manager polls <code>cook_meal</code>.</li><li>Code runs <code>println!("Start washing vegetables...")</code>.</li><li>Hits <code>chop_vegetables().await</code>, manager starts polling the chopping task.</li><li>Chopping takes time ‚Üí returns <code>Pending</code>. Manager shelves <code>cook_meal</code> and handles other recipes.</li><li>Later, an external event (I/O, timer) fires and uses the <code>Waker</code> to wake <code>cook_meal</code>.</li><li>Manager polls again; it resumes from where it paused and gets the chopped ingredients.</li><li>Hits <code>fry_in_pan().await</code>; repeat.</li><li>Eventually, <code>.poll()</code> returns <code>Ready</code>; task completes.</li></ol><p>No magic. Just a precise state machine driven by <code>poll</code> and <code>Waker</code>. Your <code>async</code> code runs in small pieces, cooperatively scheduled.</p><h2 id=recap-putting-the-elephant-in-the-fridge>Recap: Putting the elephant in the fridge<a hidden class=anchor aria-hidden=true href=#recap-putting-the-elephant-in-the-fridge>#</a></h2><table><thead><tr><th style=text-align:left>Concept</th><th style=text-align:left>Plain analogy</th><th style=text-align:left>Purpose</th></tr></thead><tbody><tr><td style=text-align:left><code>async fn</code></td><td style=text-align:left>a recipe</td><td style=text-align:left>Defines a task to run later; doesn&rsquo;t run itself.</td></tr><tr><td style=text-align:left><code>Future</code></td><td style=text-align:left>voucher + progress tracker</td><td style=text-align:left>The state machine that records where execution is.</td></tr><tr><td style=text-align:left>Executor (e.g., Tokio)</td><td style=text-align:left>tireless kitchen manager</td><td style=text-align:left>Schedules/advances many futures to keep the kitchen busy.</td></tr><tr><td style=text-align:left><code>.await</code></td><td style=text-align:left>&ldquo;wait, but don&rsquo;t idle&rdquo;</td><td style=text-align:left>Suspension point that yields control to the executor.</td></tr><tr><td style=text-align:left><code>.poll()</code></td><td style=text-align:left>&ldquo;Done yet?&rdquo;</td><td style=text-align:left>Advances the state machine one step.</td></tr><tr><td style=text-align:left><code>Waker</code></td><td style=text-align:left>timer/alarm</td><td style=text-align:left>Notifies the executor to poll again when ready.</td></tr></tbody></table><p>Next time your <code>async</code> code behaves counterintuitively, remember: it&rsquo;s not lying. It&rsquo;s faithfully following the kitchen workflow. Your job is to write good recipes and place <code>.await</code> at the right spots.</p><hr><p>Follow Rexai Programming on WeChat to unlock more dev magic.</p></div><section class=post-actions aria-label="post actions"><div class=post-actions__group><div class=post-actions__item><script type=text/javascript src=https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js data-name=bmc-button data-slug=winbbryz data-color=#FFDD00 data-emoji data-font=Cookie data-text="Buy me a coffee" data-outline-color=#000000 data-font-color=#000000 data-coffee-color=#ffffff></script></div></div></section><footer class=post-footer><ul class=post-tags><li><a href=https://rexai.top/en/tags/rust/>Rust</a></li><li><a href=https://rexai.top/en/tags/async/>Async</a></li><li><a href=https://rexai.top/en/tags/await/>Await</a></li><li><a href=https://rexai.top/en/tags/future/>Future</a></li><li><a href=https://rexai.top/en/tags/tokio/>Tokio</a></li><li><a href=https://rexai.top/en/tags/concurrency/>Concurrency</a></li><li><a href=https://rexai.top/en/tags/state-machine/>State Machine</a></li><li><a href=https://rexai.top/en/tags/waker/>Waker</a></li><li><a href=https://rexai.top/en/tags/poll/>Poll</a></li></ul></footer></article></main><footer class=footer><span>¬© <a href=https://rexai.top/>Ê¢¶ÂÖΩÁºñÁ®ã</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>