<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust Async Unveiled: The Secret to Making Code 'Slack Off' While Doubling Efficiency! | 梦兽编程</title><meta name=keywords content="Rust,async programming,async,await,Future,tokio,concurrency,zero-cost abstraction,Rust tutorial,programming tutorial"><meta name=description content="Deep dive into Rust async programming core concepts, from async/await to Future, from tokio runtime to concurrent processing. Master zero-cost async programming essence and double your Rust code efficiency!"><meta name=author content="Rexai Programming"><link rel=canonical href=https://rexai.top/en/tutorials/rust/rust-async-like-a-pro-explained/><link crossorigin=anonymous href=/assets/css/stylesheet.0b35afafaf160405c18d14073bc3e7f69e9bebb655c929b842ede7450e458ede.css integrity="sha256-CzWvr68WBAXBjRQHO8Pn9p6b67ZVySm4Qu3nRQ5Fjt4=" rel="preload stylesheet" as=style><link rel=icon href=https://rexai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rexai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rexai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://rexai.top/apple-touch-icon.png><link rel=mask-icon href=https://rexai.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://rexai.top/tutorials/rust/rust-async-like-a-pro-explained/><link rel=alternate hreflang=en href=https://rexai.top/en/tutorials/rust/rust-async-like-a-pro-explained/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/extended/modern-typography.min.css integrity><style>.promotion-section{margin-top:3rem;padding:2rem;text-align:center;background:linear-gradient(135deg,rgba(59,130,246,5%) 0%,rgba(139,92,246,5%) 100%);border-radius:16px;border:1px solid rgba(59,130,246,.1);position:relative;overflow:hidden}.promotion-section::before{content:"";position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#3b82f6,#8b5cf6,#06b6d4);border-radius:16px 16px 0 0}.promotion-section h3{margin-bottom:1.5rem;color:var(--primary);font-size:1.5rem;font-weight:600;background:linear-gradient(135deg,#3b82f6,#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.qr-codes{display:flex;gap:2.5rem;justify-content:center;flex-wrap:wrap;margin-top:2rem}.qr-item{text-align:center;position:relative;transition:transform .3s ease}.qr-item:hover{transform:translateY(-5px)}.qr-item img{width:160px;height:160px;border:2px solid #e5e7eb;border-radius:16px;padding:12px;background:#fff;box-shadow:0 4px 20px rgba(0,0,0,8%),0 1px 3px rgba(0,0,0,.1);transition:all .3s ease;position:relative;overflow:hidden}.qr-item img::before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,rgba(59,130,246,.1),rgba(139,92,246,.1));opacity:0;transition:opacity .3s ease;z-index:1}.qr-item:hover img{border-color:#3b82f6;box-shadow:0 8px 30px rgba(59,130,246,.2),0 2px 8px rgba(0,0,0,.1);transform:scale(1.02)}.qr-item:hover img::before{opacity:1}.qr-item p{margin-top:1rem;font-size:1rem;color:var(--secondary);font-weight:500;position:relative}.modern-button{display:inline-flex;align-items:center;padding:.75rem 1.5rem;background:linear-gradient(135deg,#3b82f6,#8b5cf6);color:#fff;text-decoration:none;border-radius:12px;font-weight:500;transition:all .3s ease;box-shadow:0 4px 12px rgba(59,130,246,.3);position:relative;overflow:hidden}.modern-button::before{content:"";position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent);transition:left .6s ease}.modern-button:hover::before{left:100%}.modern-button:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(59,130,246,.4)}@keyframes fadeInUp{from{opacity:0;transform:translateY(30px)}to{opacity:1;transform:translateY(0)}}.post-content>*{animation:fadeInUp .6s ease-out;animation-fill-mode:both}.post-content>*:nth-child(1){animation-delay:.1s}.post-content>*:nth-child(2){animation-delay:.2s}.post-content>*:nth-child(3){animation-delay:.3s}.post-content>*:nth-child(4){animation-delay:.4s}@media(max-width:768px){.promotion-section{margin:2rem -1rem;border-radius:0;padding:1.5rem 1rem}.qr-codes{flex-direction:column;align-items:center;gap:1.5rem}.qr-item img{width:140px;height:140px;padding:10px}.promotion-section h3{font-size:1.25rem}}.reading-progress{position:fixed;top:0;left:0;width:0%;height:3px;background:linear-gradient(90deg,#3b82f6,#8b5cf6,#06b6d4);z-index:999;transition:width .1s ease}*{transition:background-color .3s ease,color .3s ease,border-color .3s ease}::-webkit-scrollbar{width:8px}::-webkit-scrollbar-track{background:var(--theme)}::-webkit-scrollbar-thumb{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-radius:4px}::-webkit-scrollbar-thumb:hover{background:linear-gradient(135deg,#2563eb,#7c3aed)}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=document.createElement("div");e.className="reading-progress",document.body.appendChild(e);function t(){const t=document.documentElement.scrollTop||document.body.scrollTop,n=document.documentElement.scrollHeight-document.documentElement.clientHeight,s=t/n*100;e.style.width=s+"%"}window.addEventListener("scroll",t),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();const t=document.querySelector(this.getAttribute("href"));t&&t.scrollIntoView({behavior:"smooth",block:"start"})})})})</script><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-K6VQRF8T")</script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=winbbryz data-description="Support me on Buy me a coffee!" data-message data-color=#FF813F data-position=Right data-x_margin=18 data-y_margin=18></script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K6VQRF8T" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-62VF26DEY6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-62VF26DEY6")</script><meta property="og:url" content="https://rexai.top/en/tutorials/rust/rust-async-like-a-pro-explained/"><meta property="og:site_name" content="梦兽编程"><meta property="og:title" content="Rust Async Unveiled: The Secret to Making Code 'Slack Off' While Doubling Efficiency!"><meta property="og:description" content="Deep dive into Rust async programming core concepts, from async/await to Future, from tokio runtime to concurrent processing. Master zero-cost async programming essence and double your Rust code efficiency!"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2024-01-15T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-15T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta property="article:tag" content="Future"><meta property="article:tag" content="Tokio"><meta property="article:tag" content="Concurrent Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Async Unveiled: The Secret to Making Code 'Slack Off' While Doubling Efficiency!"><meta name=twitter:description content="Deep dive into Rust async programming core concepts, from async/await to Future, from tokio runtime to concurrent processing. Master zero-cost async programming essence and double your Rust code efficiency!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://rexai.top/en/tutorials/"},{"@type":"ListItem","position":2,"name":"Rust Async Unveiled: The Secret to Making Code 'Slack Off' While Doubling Efficiency!","item":"https://rexai.top/en/tutorials/rust/rust-async-like-a-pro-explained/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Async Unveiled: The Secret to Making Code 'Slack Off' While Doubling Efficiency!","name":"Rust Async Unveiled: The Secret to Making Code \u0027Slack Off\u0027 While Doubling Efficiency!","description":"Deep dive into Rust async programming core concepts, from async/await to Future, from tokio runtime to concurrent processing. Master zero-cost async programming essence and double your Rust code efficiency!","keywords":["Rust","async programming","async","await","Future","tokio","concurrency","zero-cost abstraction","Rust tutorial","programming tutorial"],"articleBody":"Rust Async Unveiled: The Secret to Making Code ‘Slack Off’ While Doubling Efficiency! Hello, future Rust master! Today we’re diving into a fascinating topic: asynchronous programming (Async).\nYou might have encountered it in JavaScript or Python, thinking of it as a behind-the-scenes hero silently handling everything. But in Rust, this “hero” operates completely differently. It doesn’t play “magic tricks” - everything is laid out in the open, both explicit and efficient, and after compilation, it’s almost “zero-cost”!\nReady to expand your mind? Let’s get started!\nFirst Stop: The async Keyword - A Promise to “Handle Later” Imagine you ask a robot to pour you a glass of water. You say to it: “Go pour me a glass of water.”\nIn the ordinary synchronous world, this robot would immediately drop everything it’s doing, run to the kitchen, find a glass, turn on the tap, wait for it to fill, then bring it back to you. During this entire process, it (and you) are “blocked” in place, unable to do anything else.\nBut what if this were an async robot?\nasync fn pour_water() { println!(\"💧 Alright, going to pour water right away!\"); } When you call pour_water(), the most amazing thing happens: it does nothing!\nThat’s right, it doesn’t go pour water. It just gives you an “IOU” - technically speaking, this is called a Future. This IOU says: “I promise to pour a glass of water in the future.”\nThe async keyword is like putting a “handle later” label on a task. It doesn’t execute any operations itself, it just packages up a “thing that will happen in the future.” In Rust, all Futures are naturally “lazy” - they won’t move unless you push them.\nSecond Stop: Future - An IOU That Needs to Be Redeemed So what exactly is this Future?\nYou can think of it as a detailed recipe. For example, an async function that calculates 21 + 21:\nasync fn compute() -\u003e u32 { 21 + 21 } The Future you get from calling compute() is a recipe that says “add 21 and 21 together.” The recipe itself can’t fill your stomach - it’s just a computation waiting to be completed.\nIn the compiler’s eyes, this Future is actually a complex struct that implements a specific trait (think of it as an interface or capability). It has a core method called poll inside, like a tireless inspector constantly asking: “Hey, is the dish ready? Can we serve it?”\nBut don’t worry, you don’t need to write such low-level code by hand for now. Rust has already beautifully hidden all of this under the async/await syntactic sugar.\nThird Stop: .await - The “Collection Call” to Redeem the Promise Since Future is so lazy, how do we make it actually move and really “pour water” or “compute”?\nThe answer is to make a “collection call” - using the .await keyword.\nBut having a collector alone isn’t enough. We also need a “project manager” to coordinate everything. In Rust’s world, this project manager is the Runtime. Rust’s standard library doesn’t come with this built-in - you need to “hire” one from the community, with the most famous being tokio.\nuse tokio; #[tokio::main] async fn main() { println!(\"I want a glass of water...\"); pour_water().await; // Hey, is this the water-pouring robot? I need water now! println!(\"Ah, the water is here, great!\"); } See that #[tokio::main]? It’s like equipping your main function with an all-powerful tokio project manager.\nWhen the code executes to pour_water().await;, several things happen:\nThe main function hands the pour_water “IOU” to the tokio manager. The main function says: “I need to wait for this glass of water, I’ll pause here for a moment and take a nap.” Then it hands over control. The tokio manager takes the IOU and immediately sends someone to execute it. While waiting for the water to be poured, the tokio manager doesn’t sit idle - it goes to handle other tasks submitted to it, like you might also have it download_file().await. Once the water is ready, the tokio manager comes back to “wake up” the sleeping main function, letting it continue from where it awaited. This is the essence of asynchronous programming: non-blocking. It’s not relying on multi-threaded parallelism (although tokio uses threads under the hood), but through clever “pausing” and “resuming” of tasks, letting a single worker thread handle hundreds or thousands of tasks simultaneously like an octopus.\nFourth Stop: The Golden Rule of Async Programming - Never Block! Imagine a busy kitchen where several chefs (tokio worker threads) are efficiently cooking dozens of dishes simultaneously. Suddenly, one chef, waiting for a pot of water to boil, just sits on a stool in front of the stove and waits, not doing anything else. The result? The entire kitchen’s efficiency drops dramatically because of this one person.\nThis is the consequence of using synchronous blocking operations in async code!\n// ❌ Disaster scene! This will make the entire chef team get stuck! std::thread::sleep(std::time::Duration::from_secs(5)); The correct approach is to use the async version of “waiting,” telling the project manager: “This pot of water needs to boil for 5 seconds, you go look at other tasks first, then come back and call me in 5 seconds.”\n// ✅ Correct posture! This chef hands over the task, then continues cutting other vegetables. tokio::time::sleep(Duration::from_secs(5)).await; Remember, in the async world, “waiting” means “yielding control,” not “hogging resources while waiting.”\nFifth Stop: Becoming a Time Management Master - Handling Multiple Futures Simultaneously What if I want to do two things that both require waiting? Like downloading a movie while unzipping a game.\nlet download_future = download_movie(); let unzip_future = unzip_game(); // Use tokio::join! to let them \"fight with both hands,\" running simultaneously! let (movie_result, game_result) = tokio::join!(download_future, unzip_future); tokio::join! is like telling the project manager: “Start these two jobs simultaneously, and report back to me when both are done.”\nThere’s an even cooler way to play, called tokio::spawn. It’s like saying: “Take this task to the background, don’t report back to me immediately, I have other things to do.” This is perfect for executing some “fire-and-forget” background tasks, like logging.\ntokio::spawn(async { log_something_in_background().await; }); Ultimate Summary: Your Rust Async Toolbox Now, let’s summarize the black magic we’ve learned with a checklist:\nasync fn: A promise that doesn’t work, only responsible for returning an IOU called Future. .await: A collection call, telling the project manager: “Stop dawdling, I want this result now!” and pausing here, yielding the CPU. tokio::main: Hiring a gold-medal project manager named tokio to schedule all your “IOUs.” join!: Time management magic, letting multiple tasks advance side by side. spawn(): Authorizing the background, letting tasks complete silently without disturbing you. Golden Rule: Never use synchronous methods to block async code, or your project manager will go on strike! Now you’ve mastered the secret of making code learn to “slack off” while dramatically improving efficiency. Go challenge yourself - write a small program using join! and spawn that can execute multiple async tasks simultaneously! You’ll discover a whole new, incredibly efficient world.\nFollow Rexai Programming WeChat Official Account to unlock more black magic.\n","wordCount":"1184","inLanguage":"en","datePublished":"2024-01-15T00:00:00Z","dateModified":"2024-01-15T00:00:00Z","author":{"@type":"Person","name":"Rexai Programming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rexai.top/en/tutorials/rust/rust-async-like-a-pro-explained/"},"publisher":{"@type":"Organization","name":"梦兽编程","logo":{"@type":"ImageObject","url":"https://rexai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rexai.top/en/ accesskey=h title="梦兽编程 (Alt + H)">梦兽编程</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://rexai.top/ title=中文 aria-label=中文>Zh-Cn</a></li></ul></div></div><button class=menu-toggle id=menu-toggle aria-label=打开菜单 aria-controls=menu aria-expanded=false>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul id=menu role=menubar><li role=none><a href=https://rexai.top/en/ title=Home role=menuitem><span>Home</span></a></li><li class=has-submenu role=none><a href=https://rexai.top/en/tutorials/ title="📚 Tutorials" role=menuitem><span>📚 Tutorials</span>
<span class=submenu-toggle role=button tabindex=0 aria-expanded=false aria-haspopup=true>▼</span></a><ul class=submenu role=menu><li role=none><a href=https://rexai.top/en/tutorials/rust/ title=Rust role=menuitem>Rust</a></li><li role=none><a href=https://rexai.top/en/tutorials/ai/ title="AI Programming" role=menuitem>AI Programming</a></li></ul></li><li role=none><a href=https://rexai.top/en/tools/ title=Tools role=menuitem><span>Tools</span></a></li><li role=none><a href=https://rexai.top/en/news/ title="🔥 News" role=menuitem><span>🔥 News</span></a></li><li role=none><a href=https://rexai.top/en/tags/ title="🏷️ Tags" role=menuitem><span>🏷️ Tags</span></a></li><li role=none><a href=https://rexai.top/en/categories/ title="📂 Categories" role=menuitem><span>📂 Categories</span></a></li></ul><div id=menu-overlay class=menu-overlay hidden></div></nav></header><style>.has-submenu{position:relative}#menu{overflow:visible !important}#menu li{overflow:visible}.submenu{position:absolute;top:100%;left:0;background:var(--theme);border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);min-width:180px;z-index:1000;list-style:none;display:none;padding:.5rem 0}.submenu li{display:block;margin:0;line-height:1.5}#menu .submenu li+li{margin-inline-start:0}.submenu a{display:block;padding:.75rem 1rem;color:var(--secondary);text-decoration:none;transition:all .2s ease;border-radius:0}.submenu a:hover{background:var(--entry);color:var(--primary)}.has-submenu:hover .submenu{display:block !important}.submenu-toggle{margin-left:.25rem;font-size:.75rem;transition:transform .2s ease;display:inline-block}.has-submenu:hover .submenu-toggle{transform:rotate(180deg)}@media(max-width:768px){.menu-toggle{display:inline-flex;align-items:center;justify-content:center;width:44px;height:44px;margin-inline-end:var(--gap);border-radius:8px;border:1px solid var(--border);background:var(--theme);color:var(--primary)}#menu{position:fixed;top:0;right:0;height:100vh;width:82vw;max-width:340px;background:var(--theme);box-shadow:-2px 0 20px rgba(0,0,0,.18);transform:translateX(100%);transition:transform .25s ease;padding:calc(var(--header-height) + 10px)16px 20px;flex-direction:column;gap:4px;overflow-y:auto !important;z-index:1001}body.menu-open #menu{transform:translateX(0)}.menu-overlay{position:fixed;inset:0;background:rgba(0,0,0,.4);opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:1000}body.menu-open .menu-overlay{opacity:1;pointer-events:auto}#menu li+li{margin-inline-start:0}#menu a{padding:12px 8px}.submenu{position:static;box-shadow:none;border:none;background:var(--entry);margin-top:0;margin-left:1rem;display:block;max-height:0;overflow:hidden;padding:0;transition:max-height .25s ease,padding .2s ease}.has-submenu.active .submenu{max-height:1000px;padding:4px 0 6px}.submenu-toggle{cursor:pointer}.has-submenu.active>a .submenu-toggle{transform:rotate(180deg)}}@media(min-width:769px){.menu-toggle{display:none}}.submenu a:focus-visible,#menu a:focus-visible,.menu-toggle:focus-visible,.submenu-toggle:focus-visible{outline:2px solid var(--primary);outline-offset:2px;border-radius:6px}@media(max-width:768px){#menu a.is-current,#menu a.is-current>span{border-bottom:none !important;background:var(--entry);color:var(--primary);border-radius:8px;font-weight:600}#menu a.is-current{padding:10px}#menu a{width:100%;border-radius:8px}#menu .active{border-bottom:none !important}}body.menu-open{overflow:hidden;touch-action:none}</style><script>(function(){const s=document.getElementById("menu"),t=document.getElementById("menu-toggle"),o=document.getElementById("menu-overlay");if(!s||!t||!o)return;const i=()=>window.innerWidth<=768,r=()=>{document.body.classList.add("menu-open"),t.setAttribute("aria-expanded","true"),o.hidden=!1,l()},n=()=>{document.body.classList.remove("menu-open"),t.setAttribute("aria-expanded","false"),o.hidden=!0,d(),t.focus()};t.addEventListener("click",()=>{const e=document.body.classList.contains("menu-open");e?n():r()}),o.addEventListener("click",n),window.addEventListener("keydown",e=>{e.key==="Escape"&&n()}),window.addEventListener("resize",()=>{window.innerWidth>768&&n()});const c=()=>{const e=Array.from(document.querySelectorAll(".has-submenu")),t=t=>{e.forEach(e=>{if(e!==t&&e.classList.contains("active")){e.classList.remove("active");const t=e.querySelector(".submenu-toggle");t&&t.setAttribute("aria-expanded","false")}})};e.forEach(e=>{const o=e.querySelector("a"),n=e.querySelector(".submenu-toggle"),a=e.querySelector(".submenu");if(!n||!a||!o)return;const r=t=>{n.setAttribute("aria-expanded",t?"true":"false"),e.classList.toggle("active",t)},s=()=>{const n=!e.classList.contains("active");n&&t(e),r(n)};n.addEventListener("click",e=>{if(!i())return;e.preventDefault(),e.stopPropagation(),s()}),n.addEventListener("keydown",e=>{if(!i())return;(e.key==="Enter"||e.key===" ")&&(e.preventDefault(),e.stopPropagation(),s())}),o.addEventListener("click",e=>{if(!i())return;e.preventDefault(),e.stopPropagation(),s()})})};let e=[];const a=t=>{if(t.key!=="Tab"||!document.body.classList.contains("menu-open"))return;e=Array.from(s.querySelectorAll('a, button, [tabindex="0"]'));const n=e[0],o=e[e.length-1];if(!n||!o)return;t.shiftKey&&document.activeElement===n?(t.preventDefault(),o.focus()):!t.shiftKey&&document.activeElement===o&&(t.preventDefault(),n.focus())},l=()=>{e=Array.from(s.querySelectorAll('a, button, [tabindex="0"]')),e.length&&e[0].focus(),document.addEventListener("keydown",a)},d=()=>{document.removeEventListener("keydown",a)};c(),s.addEventListener("click",e=>{const t=e.target;if(!(t instanceof Element)||!i())return;const s=t.closest("a");if(!s)return;const o=s.closest("li"),a=o&&o.classList.contains("has-submenu");a||n()})})()</script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rust Async Unveiled: The Secret to Making Code 'Slack Off' While Doubling Efficiency!</h1><div class=post-description>Deep dive into Rust async programming core concepts, from async/await to Future, from tokio runtime to concurrent processing. Master zero-cost async programming essence and double your Rust code efficiency!</div><div class=post-meta><span title='2024-01-15 00:00:00 +0000 UTC'>January 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1184 words&nbsp;·&nbsp;Rexai Programming&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://rexai.top/tutorials/rust/rust-async-like-a-pro-explained/>Zh-Cn</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#rust-async-unveiled-the-secret-to-making-code-slack-off-while-doubling-efficiency aria-label="Rust Async Unveiled: The Secret to Making Code &lsquo;Slack Off&rsquo; While Doubling Efficiency!">Rust Async Unveiled: The Secret to Making Code &lsquo;Slack Off&rsquo; While Doubling Efficiency!</a><ul><li><a href=#first-stop-the aria-label="First Stop: The async Keyword - A Promise to &ldquo;Handle Later&rdquo;">First Stop: The async Keyword - A Promise to &ldquo;Handle Later&rdquo;</a></li><li><a href=#second-stop aria-label="Second Stop: Future - An IOU That Needs to Be Redeemed">Second Stop: Future - An IOU That Needs to Be Redeemed</a></li><li><a href=#third-stop aria-label="Third Stop: .await - The &ldquo;Collection Call&rdquo; to Redeem the Promise">Third Stop: .await - The &ldquo;Collection Call&rdquo; to Redeem the Promise</a></li><li><a href=#fourth-stop-the-golden-rule-of-async-programming---never-block aria-label="Fourth Stop: The Golden Rule of Async Programming - Never Block!">Fourth Stop: The Golden Rule of Async Programming - Never Block!</a></li><li><a href=#fifth-stop-becoming-a-time-management-master---handling-multiple-futures-simultaneously aria-label="Fifth Stop: Becoming a Time Management Master - Handling Multiple Futures Simultaneously">Fifth Stop: Becoming a Time Management Master - Handling Multiple Futures Simultaneously</a></li><li><a href=#ultimate-summary-your-rust-async-toolbox aria-label="Ultimate Summary: Your Rust Async Toolbox">Ultimate Summary: Your Rust Async Toolbox</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=rust-async-unveiled-the-secret-to-making-code-slack-off-while-doubling-efficiency>Rust Async Unveiled: The Secret to Making Code &lsquo;Slack Off&rsquo; While Doubling Efficiency!<a hidden class=anchor aria-hidden=true href=#rust-async-unveiled-the-secret-to-making-code-slack-off-while-doubling-efficiency>#</a></h1><p>Hello, future Rust master! Today we&rsquo;re diving into a fascinating topic: asynchronous programming (Async).</p><p>You might have encountered it in JavaScript or Python, thinking of it as a behind-the-scenes hero silently handling everything. But in Rust, this &ldquo;hero&rdquo; operates completely differently. It doesn&rsquo;t play &ldquo;magic tricks&rdquo; - everything is laid out in the open, both explicit and efficient, and after compilation, it&rsquo;s almost &ldquo;zero-cost&rdquo;!</p><p>Ready to expand your mind? Let&rsquo;s get started!</p><h2 id=first-stop-the><strong>First Stop: The <code>async</code> Keyword - A Promise to &ldquo;Handle Later&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#first-stop-the>#</a></h2><p>Imagine you ask a robot to pour you a glass of water. You say to it: &ldquo;Go pour me a glass of water.&rdquo;</p><p>In the ordinary synchronous world, this robot would immediately drop everything it&rsquo;s doing, run to the kitchen, find a glass, turn on the tap, wait for it to fill, then bring it back to you. During this entire process, it (and you) are &ldquo;blocked&rdquo; in place, unable to do anything else.</p><p>But what if this were an <code>async</code> robot?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>pour_water</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;💧 Alright, going to pour water right away!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When you call <code>pour_water()</code>, the most amazing thing happens: <strong>it does nothing!</strong></p><p>That&rsquo;s right, it doesn&rsquo;t go pour water. It just gives you an &ldquo;IOU&rdquo; - technically speaking, this is called a <code>Future</code>. This IOU says: &ldquo;I promise to pour a glass of water in the future.&rdquo;</p><p>The <code>async</code> keyword is like putting a &ldquo;handle later&rdquo; label on a task. It doesn&rsquo;t execute any operations itself, it just packages up a &ldquo;thing that will happen in the future.&rdquo; In Rust, all <code>Future</code>s are naturally &ldquo;lazy&rdquo; - they won&rsquo;t move unless you push them.</p><h2 id=second-stop><strong>Second Stop: <code>Future</code> - An IOU That Needs to Be Redeemed</strong><a hidden class=anchor aria-hidden=true href=#second-stop>#</a></h2><p>So what exactly is this <code>Future</code>?</p><p>You can think of it as a detailed recipe. For example, an <code>async</code> function that calculates <code>21 + 21</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compute</span>() -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>21</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Future</code> you get from calling <code>compute()</code> is a recipe that says &ldquo;add 21 and 21 together.&rdquo; The recipe itself can&rsquo;t fill your stomach - it&rsquo;s just a computation waiting to be completed.</p><p>In the compiler&rsquo;s eyes, this <code>Future</code> is actually a complex struct that implements a specific <code>trait</code> (think of it as an interface or capability). It has a core method called <code>poll</code> inside, like a tireless inspector constantly asking: &ldquo;Hey, is the dish ready? Can we serve it?&rdquo;</p><p>But don&rsquo;t worry, you don&rsquo;t need to write such low-level code by hand for now. Rust has already beautifully hidden all of this under the <code>async/await</code> syntactic sugar.</p><h2 id=third-stop><strong>Third Stop: <code>.await</code> - The &ldquo;Collection Call&rdquo; to Redeem the Promise</strong><a hidden class=anchor aria-hidden=true href=#third-stop>#</a></h2><p>Since <code>Future</code> is so lazy, how do we make it actually move and really &ldquo;pour water&rdquo; or &ldquo;compute&rdquo;?</p><p>The answer is to make a &ldquo;collection call&rdquo; - using the <code>.await</code> keyword.</p><p>But having a collector alone isn&rsquo;t enough. We also need a &ldquo;project manager&rdquo; to coordinate everything. In Rust&rsquo;s world, this project manager is the <strong>Runtime</strong>. Rust&rsquo;s standard library doesn&rsquo;t come with this built-in - you need to &ldquo;hire&rdquo; one from the community, with the most famous being <code>tokio</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;I want a glass of water...&#34;</span>);
</span></span><span style=display:flex><span>    pour_water().<span style=color:#66d9ef>await</span>; <span style=color:#75715e>// Hey, is this the water-pouring robot? I need water now!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Ah, the water is here, great!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>See that <code>#[tokio::main]</code>? It&rsquo;s like equipping your <code>main</code> function with an all-powerful <code>tokio</code> project manager.</p><p>When the code executes to <code>pour_water().await;</code>, several things happen:</p><ol><li>The <code>main</code> function hands the <code>pour_water</code> &ldquo;IOU&rdquo; to the <code>tokio</code> manager.</li><li>The <code>main</code> function says: &ldquo;I need to wait for this glass of water, I&rsquo;ll pause here for a moment and take a nap.&rdquo; Then it hands over control.</li><li>The <code>tokio</code> manager takes the IOU and immediately sends someone to execute it.</li><li>While waiting for the water to be poured, the <code>tokio</code> manager doesn&rsquo;t sit idle - it goes to handle other tasks submitted to it, like you might also have it <code>download_file().await</code>.</li><li>Once the water is ready, the <code>tokio</code> manager comes back to &ldquo;wake up&rdquo; the sleeping <code>main</code> function, letting it continue from where it <code>await</code>ed.</li></ol><p>This is the essence of asynchronous programming: <strong>non-blocking</strong>. It&rsquo;s not relying on multi-threaded parallelism (although <code>tokio</code> uses threads under the hood), but through clever &ldquo;pausing&rdquo; and &ldquo;resuming&rdquo; of tasks, letting a single worker thread handle hundreds or thousands of tasks simultaneously like an octopus.</p><h2 id=fourth-stop-the-golden-rule-of-async-programming---never-block><strong>Fourth Stop: The Golden Rule of Async Programming - Never Block!</strong><a hidden class=anchor aria-hidden=true href=#fourth-stop-the-golden-rule-of-async-programming---never-block>#</a></h2><p>Imagine a busy kitchen where several chefs (<code>tokio</code> worker threads) are efficiently cooking dozens of dishes simultaneously. Suddenly, one chef, waiting for a pot of water to boil, just sits on a stool in front of the stove and waits, not doing anything else. The result? The entire kitchen&rsquo;s efficiency drops dramatically because of this one person.</p><p>This is the consequence of using synchronous blocking operations in async code!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// ❌ Disaster scene! This will make the entire chef team get stuck!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std::thread::sleep(std::time::Duration::from_secs(<span style=color:#ae81ff>5</span>));
</span></span></code></pre></div><p>The correct approach is to use the async version of &ldquo;waiting,&rdquo; telling the project manager: &ldquo;This pot of water needs to boil for 5 seconds, you go look at other tasks first, then come back and call me in 5 seconds.&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// ✅ Correct posture! This chef hands over the task, then continues cutting other vegetables.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>tokio::time::sleep(Duration::from_secs(<span style=color:#ae81ff>5</span>)).<span style=color:#66d9ef>await</span>;
</span></span></code></pre></div><p>Remember, in the async world, <strong>&ldquo;waiting&rdquo; means &ldquo;yielding control,&rdquo; not &ldquo;hogging resources while waiting.&rdquo;</strong></p><h2 id=fifth-stop-becoming-a-time-management-master---handling-multiple-futures-simultaneously><strong>Fifth Stop: Becoming a Time Management Master - Handling Multiple Futures Simultaneously</strong><a hidden class=anchor aria-hidden=true href=#fifth-stop-becoming-a-time-management-master---handling-multiple-futures-simultaneously>#</a></h2><p>What if I want to do two things that both require waiting? Like downloading a movie while unzipping a game.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> download_future <span style=color:#f92672>=</span> download_movie();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> unzip_future <span style=color:#f92672>=</span> unzip_game();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use tokio::join! to let them &#34;fight with both hands,&#34; running simultaneously!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> (movie_result, game_result) <span style=color:#f92672>=</span> tokio::<span style=color:#a6e22e>join!</span>(download_future, unzip_future);
</span></span></code></pre></div><p><code>tokio::join!</code> is like telling the project manager: &ldquo;Start these two jobs simultaneously, and report back to me when both are done.&rdquo;</p><p>There&rsquo;s an even cooler way to play, called <code>tokio::spawn</code>. It&rsquo;s like saying: &ldquo;Take this task to the background, don&rsquo;t report back to me immediately, I have other things to do.&rdquo; This is perfect for executing some &ldquo;fire-and-forget&rdquo; background tasks, like logging.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>tokio::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>    log_something_in_background().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=ultimate-summary-your-rust-async-toolbox><strong>Ultimate Summary: Your Rust Async Toolbox</strong><a hidden class=anchor aria-hidden=true href=#ultimate-summary-your-rust-async-toolbox>#</a></h2><p>Now, let&rsquo;s summarize the black magic we&rsquo;ve learned with a checklist:</p><ul><li><strong><code>async fn</code></strong>: A promise that doesn&rsquo;t work, only responsible for returning an IOU called <code>Future</code>.</li><li><strong><code>.await</code></strong>: A collection call, telling the project manager: &ldquo;Stop dawdling, I want this result now!&rdquo; and pausing here, yielding the CPU.</li><li><strong><code>tokio::main</code></strong>: Hiring a gold-medal project manager named <code>tokio</code> to schedule all your &ldquo;IOUs.&rdquo;</li><li><strong><code>join!</code></strong>: Time management magic, letting multiple tasks advance side by side.</li><li><strong><code>spawn()</code></strong>: Authorizing the background, letting tasks complete silently without disturbing you.</li><li><strong>Golden Rule</strong>: Never use synchronous methods to block async code, or your project manager will go on strike!</li></ul><p>Now you&rsquo;ve mastered the secret of making code learn to &ldquo;slack off&rdquo; while dramatically improving efficiency. Go challenge yourself - write a small program using <code>join!</code> and <code>spawn</code> that can execute multiple async tasks simultaneously! You&rsquo;ll discover a whole new, incredibly efficient world.</p><hr><p><strong>Follow Rexai Programming WeChat Official Account to unlock more black magic.</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rexai.top/en/tags/rust/>Rust</a></li><li><a href=https://rexai.top/en/tags/async/>Async</a></li><li><a href=https://rexai.top/en/tags/await/>Await</a></li><li><a href=https://rexai.top/en/tags/future/>Future</a></li><li><a href=https://rexai.top/en/tags/tokio/>Tokio</a></li><li><a href=https://rexai.top/en/tags/concurrent-programming/>Concurrent Programming</a></li><li><a href=https://rexai.top/en/tags/zero-cost-abstraction/>Zero-Cost Abstraction</a></li><li><a href=https://rexai.top/en/tags/programming-tutorial/>Programming Tutorial</a></li></ul></footer></article></main><footer class=footer><span>© <a href=https://rexai.top/>梦兽编程</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>