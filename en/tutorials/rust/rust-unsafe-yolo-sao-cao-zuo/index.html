<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust unsafe isnâ€™t a toy â€” itâ€™s a blood oath: 6 YOLO mistakes that will blow up your code | æ¢¦å…½ç¼–ç¨‹</title><meta name=keywords content="Rust,unsafe,memory safety,raw pointer,FFI,Send,Sync,data race,borrow checker,concurrency,performance,Rust tutorial"><meta name=description content="Donâ€™t treat unsafe like a get-out-of-jail-free card. With practical examples, this article dissects 6 common unsafe pitfalls: silencing the compiler with duct tape, dereferencing random raw pointers, violating borrow rules inside unsafe, reinventing wheels, abusing unsafe impl, and skipping Safety comments â€” helping you build the right risk mindset and usage patterns."><meta name=author content="Rexai Programming"><link rel=canonical href=https://rexai.top/en/tutorials/rust/rust-unsafe-yolo-sao-cao-zuo/><link crossorigin=anonymous href=/assets/css/stylesheet.36a35dd316f612e0d26c90cd90313d15705d24943d7cf2559674e92b21704616.css integrity="sha256-NqNd0xb2EuDSbJDNkDE9FXBdJJQ9fPJVlnTpKyFwRhY=" rel="preload stylesheet" as=style><link rel=icon href=https://rexai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rexai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rexai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://rexai.top/apple-touch-icon.png><link rel=mask-icon href=https://rexai.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://rexai.top/tutorials/rust/rust-unsafe-yolo-sao-cao-zuo/><link rel=alternate hreflang=en href=https://rexai.top/en/tutorials/rust/rust-unsafe-yolo-sao-cao-zuo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/extended/modern-typography.min.css integrity><style>.promotion-section{margin-top:3rem;padding:2rem;text-align:center;background:linear-gradient(135deg,rgba(59,130,246,5%) 0%,rgba(139,92,246,5%) 100%);border-radius:16px;border:1px solid rgba(59,130,246,.1);position:relative;overflow:hidden}.promotion-section::before{content:"";position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#3b82f6,#8b5cf6,#06b6d4);border-radius:16px 16px 0 0}.promotion-section h3{margin-bottom:1.5rem;color:var(--primary);font-size:1.5rem;font-weight:600;background:linear-gradient(135deg,#3b82f6,#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.qr-codes{display:flex;gap:2.5rem;justify-content:center;flex-wrap:wrap;margin-top:2rem}.qr-item{text-align:center;position:relative;transition:transform .3s ease}.qr-item:hover{transform:translateY(-5px)}.qr-item img{width:160px;height:160px;border:2px solid #e5e7eb;border-radius:16px;padding:12px;background:#fff;box-shadow:0 4px 20px rgba(0,0,0,8%),0 1px 3px rgba(0,0,0,.1);transition:all .3s ease;position:relative;overflow:hidden}.qr-item img::before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,rgba(59,130,246,.1),rgba(139,92,246,.1));opacity:0;transition:opacity .3s ease;z-index:1}.qr-item:hover img{border-color:#3b82f6;box-shadow:0 8px 30px rgba(59,130,246,.2),0 2px 8px rgba(0,0,0,.1);transform:scale(1.02)}.qr-item:hover img::before{opacity:1}.qr-item p{margin-top:1rem;font-size:1rem;color:var(--secondary);font-weight:500;position:relative}.modern-button{display:inline-flex;align-items:center;padding:.75rem 1.5rem;background:linear-gradient(135deg,#3b82f6,#8b5cf6);color:#fff;text-decoration:none;border-radius:12px;font-weight:500;transition:all .3s ease;box-shadow:0 4px 12px rgba(59,130,246,.3);position:relative;overflow:hidden}.modern-button::before{content:"";position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent);transition:left .6s ease}.modern-button:hover::before{left:100%}.modern-button:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(59,130,246,.4)}@keyframes fadeInUp{from{opacity:0;transform:translateY(30px)}to{opacity:1;transform:translateY(0)}}.post-content>*{animation:fadeInUp .6s ease-out;animation-fill-mode:both}.post-content>*:nth-child(1){animation-delay:.1s}.post-content>*:nth-child(2){animation-delay:.2s}.post-content>*:nth-child(3){animation-delay:.3s}.post-content>*:nth-child(4){animation-delay:.4s}@media(max-width:768px){.promotion-section{margin:2rem -1rem;border-radius:0;padding:1.5rem 1rem}.qr-codes{flex-direction:column;align-items:center;gap:1.5rem}.qr-item img{width:140px;height:140px;padding:10px}.promotion-section h3{font-size:1.25rem}}.reading-progress{position:fixed;top:0;left:0;width:0%;height:3px;background:linear-gradient(90deg,#3b82f6,#8b5cf6,#06b6d4);z-index:999;transition:width .1s ease}.post-actions{margin-top:2.5rem;padding-top:1.25rem;border-top:1px dashed var(--border)}.post-actions__group{display:flex;flex-wrap:wrap;gap:.75rem 1rem;align-items:center}.post-actions__item{display:inline-flex;align-items:center}*{transition:background-color .3s ease,color .3s ease,border-color .3s ease}::-webkit-scrollbar{width:8px}::-webkit-scrollbar-track{background:var(--theme)}::-webkit-scrollbar-thumb{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-radius:4px}::-webkit-scrollbar-thumb:hover{background:linear-gradient(135deg,#2563eb,#7c3aed)}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=document.createElement("div");e.className="reading-progress",document.body.appendChild(e);function t(){const t=document.documentElement.scrollTop||document.body.scrollTop,n=document.documentElement.scrollHeight-document.documentElement.clientHeight,s=t/n*100;e.style.width=s+"%"}window.addEventListener("scroll",t),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();const t=document.querySelector(this.getAttribute("href"));t&&t.scrollIntoView({behavior:"smooth",block:"start"})})})})</script><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-K6VQRF8T")</script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K6VQRF8T" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-62VF26DEY6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-62VF26DEY6")</script><meta property="og:url" content="https://rexai.top/en/tutorials/rust/rust-unsafe-yolo-sao-cao-zuo/"><meta property="og:site_name" content="æ¢¦å…½ç¼–ç¨‹"><meta property="og:title" content="Rust unsafe isnâ€™t a toy â€” itâ€™s a blood oath: 6 YOLO mistakes that will blow up your code"><meta property="og:description" content="Donâ€™t treat unsafe like a get-out-of-jail-free card. With practical examples, this article dissects 6 common unsafe pitfalls: silencing the compiler with duct tape, dereferencing random raw pointers, violating borrow rules inside unsafe, reinventing wheels, abusing unsafe impl, and skipping Safety comments â€” helping you build the right risk mindset and usage patterns."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2025-08-13T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-13T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Unsafe"><meta property="article:tag" content="Memory-Safety"><meta property="article:tag" content="Pointers"><meta property="article:tag" content="FFI"><meta property="article:tag" content="Concurrency"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust unsafe isnâ€™t a toy â€” itâ€™s a blood oath: 6 YOLO mistakes that will blow up your code"><meta name=twitter:description content="Donâ€™t treat unsafe like a get-out-of-jail-free card. With practical examples, this article dissects 6 common unsafe pitfalls: silencing the compiler with duct tape, dereferencing random raw pointers, violating borrow rules inside unsafe, reinventing wheels, abusing unsafe impl, and skipping Safety comments â€” helping you build the right risk mindset and usage patterns."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://rexai.top/en/tutorials/"},{"@type":"ListItem","position":2,"name":"Rust unsafe isnâ€™t a toy â€” itâ€™s a blood oath: 6 YOLO mistakes that will blow up your code","item":"https://rexai.top/en/tutorials/rust/rust-unsafe-yolo-sao-cao-zuo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust unsafe isnâ€™t a toy â€” itâ€™s a blood oath: 6 YOLO mistakes that will blow up your code","name":"Rust unsafe isnâ€™t a toy â€” itâ€™s a blood oath: 6 YOLO mistakes that will blow up your code","description":"Donâ€™t treat unsafe like a get-out-of-jail-free card. With practical examples, this article dissects 6 common unsafe pitfalls: silencing the compiler with duct tape, dereferencing random raw pointers, violating borrow rules inside unsafe, reinventing wheels, abusing unsafe impl, and skipping Safety comments â€” helping you build the right risk mindset and usage patterns.","keywords":["Rust","unsafe","memory safety","raw pointer","FFI","Send","Sync","data race","borrow checker","concurrency","performance","Rust tutorial"],"articleBody":"Friend, have you had a night like this?\nOn the screen, the Rust compilerâ€™s scarlet errors grip your project by the throat. Lifetimes, ownership, borrow rules â€” the guardians youâ€™re usually proud of suddenly feel like a never-ending lecture you just want to shut up.\nRight when youâ€™re about to give up and smash the keyboard, a word glows in your mind with devilish temptation â€” unsafe.\nIt feels like a cheat code, a God-mode switch that makes all red squiggles vanish. You wrap those â€œproblematicâ€ lines inside a sacred block, type cargo buildâ€¦ Success! Silence.\nYou breathe out, feeling like a hero who tamed a dragon. But behind the compilerâ€™s silence, thereâ€™s a disdainful glance that says: â€œFine. Play your way â€” but what happens next is on you.â€\nunsafe: not a get-out-of-jail-free card, but your signed blood oath Letâ€™s rip off the free-spirited mask of unsafe and face its brutal truth.\nIn Rust, unsafe does not mean â€œturn off all safety checks and YOLO.â€ It truly means:\nâ€œMe, the mighty programmer, solemnly swear to personally take responsibility for memory safety in this code region. What the compiler canâ€™t see, I understand; what it canâ€™t check, I guarantee. If the program crashes, leaks, corrupts data â€” even explodes servers or sinks the company â€” I alone will bear it.â€\nYouâ€™re not turning off the rules; youâ€™re signing a waiver. Youâ€™re telling the compiler, â€œIâ€™ve got this region. If it goes south, thatâ€™s on me.â€\nItâ€™s like disabling the worldâ€™s best ADAS in your car because itâ€™s â€œtoo naggy,â€ then flooring the pedal. Sure, itâ€™s thrilling â€” but whether a cliff or an open road lies ahead depends entirely on your skill and luck.\nMost of us think weâ€™re drift legends. Usually, weâ€™re rookies. To keep you from flying off the mountain road, here are the most common â€œYOLOâ€ misuses of unsafe.\nSin 1: Using unsafe as duct tape to silence the compiler This is the most common â€” and the dumbest â€” mistake. You hit a lifetime or ownership issue, and instead of understanding it, you just slap an unsafe block around it to shut the compiler up.\nExample:\nlet r: \u0026i32; unsafe { r = std::mem::transmute(0x123456usize); } println!(\"{r}\"); You coerced an arbitrary memory address 0x123456 into an \u0026i32. The compiler, gagged by your unsafe, can only watch.\nConsequence: It compiles, then crashes. Or worse â€” it doesnâ€™t crash, but data silently rots. Three months later, a client calls at 3 a.m. and you have no idea where to start.\nMantra: Every compiler error is like your mom telling you itâ€™s cold outside. She may not be trendy, but sheâ€™s not trying to hurt you. Before you silence the compiler with unsafe, ask: am I really smarter than a system forged by decades of design and collective wisdom?\nSin 2: Holding a master key and opening mystery boxes Raw pointers are regulars in the unsafe world. They are keys that can point anywhere in memory. Some newcomers get the key and go door-hopping with random addresses.\nExample:\nlet ptr = 0x123456usize as *const i32; unsafe { println!(\"{}\", *ptr); // Guess whatâ€™s in here? } You assigned a fixed address to ptr and confidently dereferenced it.\nConsequence: This is Russian roulette. That address might be nothing, OS internals, or someone elseâ€™s secrets. Best case: instant crash. Worse: weird, heisenbuggy corruption.\nMantra: unsafe grants you the right to open a lock â€” but only when youâ€™re 100% sure the lock is your safe, not a munitions depot. Only dereference pointers you created from known-good objects.\nCorrect posture:\nlet x = 42; // Create a pointer from a known, valid value let ptr = \u0026x as *const i32; unsafe { // SAFETY: We know ptr points to x, which is alive and valid. println!(\"safe ptr: {}\", *ptr); // 42 } Sin 3: Thinking unsafe is a lawless zone Many believe that inside an unsafe block, Rustâ€™s rules vanish and you can do anything.\nNo. unsafe is diplomatic immunity for five specific powers. If you violate borrow rules, Rust will still tackle you to the ground.\nExample:\nunsafe { let mut v = vec![1, 2, 3]; let x = \u0026v[0]; v.push(4); // Borrow rules still apply println!(\"{x}\"); } Even inside unsafe, this wonâ€™t compile. You tried to hold an immutable borrow (x) and then mutate (v.push(4)) â€” a red line in Rust.\nMantra: unsafe only allows five things:\nDereference raw pointers Call unsafe or external (FFI) functions Access or mutate mutable statics Access union fields Implement unsafe traits For everything else, youâ€™re still a good Rust citizen.\nSin 4: Reinventing wheels â€” square ones When dealing with C libraries or C-strings, you might think, â€œI can write a strlen with unsafe. Cool!â€\nExample:\n// A manual C-style strlen unsafe fn strlen(ptr: *const u8) -\u003e usize { let mut len = 0; while *ptr.add(len) != 0 { len += 1; } len } Looks hackerish, but you likely produced a buggy, slower square wheel.\nMantra: Before writing unsafe, repeat: â€œAm I reinventing a wheel?â€ Rustâ€™s std and ecosystem already provide safe, battle-tested abstractions for almost everything low-level.\nCorrect posture:\nuse std::ffi::CStr; fn main() { let c_string_bytes = b\"hello\\0\"; // Note the trailing \\0 let c_str_ptr = c_string_bytes.as_ptr() as *const i8; let cstr = unsafe { // SAFETY: The pointer is valid and points to a NUL-terminated C string. CStr::from_ptr(c_str_ptr) }; println!(\"Use the wheel that exists: {:?}\", cstr); } Sin 5: â€œIâ€™m the inspectorâ€ â€” abusing unsafe impl This is one of the most dangerous easy-to-abuse features: unsafe impl.\nWhen you write unsafe impl Send for MyType {}, youâ€™re swearing to the concurrency gods that MyType can be safely moved across threads â€” no data races, no UB.\nThe compiler trusts you completely.\nExample:\nstruct MyType { ptr: *mut i32, // raw pointer, yikes } unsafe impl Send for MyType {} // boom Consequence: You planted a time bomb in your concurrent code. Everything looks fine in single-threaded tests; in production, two threads touch the same raw pointer and now you have races, corruption, crashes â€” ghosts you canâ€™t catch.\nMantra: unsafe impl Send and unsafe impl Sync are nuclear buttons. Unless youâ€™re writing very low-level concurrency primitives and truly understand the memory model, atomics, and data-race freedom, donâ€™t touch them.\nFor 99.99% of cases, use safe primitives like Arc","wordCount":"1278","inLanguage":"en","datePublished":"2025-08-13T00:00:00Z","dateModified":"2025-08-13T00:00:00Z","author":{"@type":"Person","name":"Rexai Programming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rexai.top/en/tutorials/rust/rust-unsafe-yolo-sao-cao-zuo/"},"publisher":{"@type":"Organization","name":"æ¢¦å…½ç¼–ç¨‹","logo":{"@type":"ImageObject","url":"https://rexai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rexai.top/en/ accesskey=h title="æ¢¦å…½ç¼–ç¨‹ (Alt + H)">æ¢¦å…½ç¼–ç¨‹</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://rexai.top/ title=ä¸­æ–‡ aria-label=ä¸­æ–‡>Zh-Cn</a></li></ul></div></div><button class=menu-toggle id=menu-toggle aria-label=æ‰“å¼€èœå• aria-controls=menu aria-expanded=false>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul id=menu role=menubar><li role=none><a href=https://rexai.top/en/ title=Home role=menuitem><span>Home</span></a></li><li class=has-submenu role=none><a href=https://rexai.top/en/tutorials/ title="ğŸ“š Tutorials" role=menuitem><span>ğŸ“š Tutorials</span>
<span class=submenu-toggle role=button tabindex=0 aria-expanded=false aria-haspopup=true>â–¼</span></a><ul class=submenu role=menu><li role=none><a href=https://rexai.top/en/tutorials/rust/ title=Rust role=menuitem>Rust</a></li><li role=none><a href=https://rexai.top/en/tutorials/ai/ title="AI Programming" role=menuitem>AI Programming</a></li></ul></li><li role=none><a href=https://rexai.top/en/tools/ title=Tools role=menuitem><span>Tools</span></a></li><li role=none><a href=https://rexai.top/en/news/ title="ğŸ”¥ News" role=menuitem><span>ğŸ”¥ News</span></a></li><li role=none><a href=https://rexai.top/en/tags/ title="ğŸ·ï¸ Tags" role=menuitem><span>ğŸ·ï¸ Tags</span></a></li><li role=none><a href=https://rexai.top/en/categories/ title="ğŸ“‚ Categories" role=menuitem><span>ğŸ“‚ Categories</span></a></li></ul><div id=menu-overlay class=menu-overlay hidden></div></nav></header><style>.has-submenu{position:relative}#menu{overflow:visible !important}#menu li{overflow:visible}.submenu{position:absolute;top:100%;left:0;background:var(--theme);border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);min-width:180px;z-index:1000;list-style:none;display:none;padding:.5rem 0}.submenu li{display:block;margin:0;line-height:1.5}#menu .submenu li+li{margin-inline-start:0}.submenu a{display:block;padding:.75rem 1rem;color:var(--secondary);text-decoration:none;transition:all .2s ease;border-radius:0}.submenu a:hover{background:var(--entry);color:var(--primary)}.has-submenu:hover .submenu{display:block !important}.submenu-toggle{margin-left:.25rem;font-size:.75rem;transition:transform .2s ease;display:inline-block}.has-submenu:hover .submenu-toggle{transform:rotate(180deg)}@media(max-width:768px){.menu-toggle{display:inline-flex;align-items:center;justify-content:center;width:44px;height:44px;margin-inline-end:var(--gap);border-radius:8px;border:1px solid var(--border);background:var(--theme);color:var(--primary)}#menu{position:fixed;top:0;right:0;height:100vh;width:82vw;max-width:340px;background:var(--theme);box-shadow:-2px 0 20px rgba(0,0,0,.18);transform:translateX(100%);transition:transform .25s ease;padding:calc(var(--header-height) + 10px)16px 20px;flex-direction:column;gap:4px;overflow-y:auto !important;z-index:1001}body.menu-open #menu{transform:translateX(0)}.menu-overlay{position:fixed;inset:0;background:rgba(0,0,0,.4);opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:1000}body.menu-open .menu-overlay{opacity:1;pointer-events:auto}#menu li+li{margin-inline-start:0}#menu a{padding:12px 8px}.submenu{position:static;box-shadow:none;border:none;background:var(--entry);margin-top:0;margin-left:1rem;display:block;max-height:0;overflow:hidden;padding:0;transition:max-height .25s ease,padding .2s ease}.has-submenu.active .submenu{max-height:1000px;padding:4px 0 6px}.submenu-toggle{cursor:pointer}.has-submenu.active>a .submenu-toggle{transform:rotate(180deg)}}@media(min-width:769px){.menu-toggle{display:none}}.submenu a:focus-visible,#menu a:focus-visible,.menu-toggle:focus-visible,.submenu-toggle:focus-visible{outline:2px solid var(--primary);outline-offset:2px;border-radius:6px}@media(max-width:768px){#menu a.is-current,#menu a.is-current>span{border-bottom:none !important;background:var(--entry);color:var(--primary);border-radius:8px;font-weight:600}#menu a.is-current{padding:10px}#menu a{width:100%;border-radius:8px}#menu .active{border-bottom:none !important}}body.menu-open{overflow:hidden;touch-action:none}</style><script>(function(){const s=document.getElementById("menu"),t=document.getElementById("menu-toggle"),o=document.getElementById("menu-overlay");if(!s||!t||!o)return;const i=()=>window.innerWidth<=768,r=()=>{document.body.classList.add("menu-open"),t.setAttribute("aria-expanded","true"),o.hidden=!1,l()},n=()=>{document.body.classList.remove("menu-open"),t.setAttribute("aria-expanded","false"),o.hidden=!0,d(),t.focus()};t.addEventListener("click",()=>{const e=document.body.classList.contains("menu-open");e?n():r()}),o.addEventListener("click",n),window.addEventListener("keydown",e=>{e.key==="Escape"&&n()}),window.addEventListener("resize",()=>{window.innerWidth>768&&n()});const c=()=>{const e=Array.from(document.querySelectorAll(".has-submenu")),t=t=>{e.forEach(e=>{if(e!==t&&e.classList.contains("active")){e.classList.remove("active");const t=e.querySelector(".submenu-toggle");t&&t.setAttribute("aria-expanded","false")}})};e.forEach(e=>{const o=e.querySelector("a"),n=e.querySelector(".submenu-toggle"),a=e.querySelector(".submenu");if(!n||!a||!o)return;const r=t=>{n.setAttribute("aria-expanded",t?"true":"false"),e.classList.toggle("active",t)},s=()=>{const n=!e.classList.contains("active");n&&t(e),r(n)};n.addEventListener("click",e=>{if(!i())return;e.preventDefault(),e.stopPropagation(),s()}),n.addEventListener("keydown",e=>{if(!i())return;(e.key==="Enter"||e.key===" ")&&(e.preventDefault(),e.stopPropagation(),s())}),o.addEventListener("click",e=>{if(!i())return;e.preventDefault(),e.stopPropagation(),s()})})};let e=[];const a=t=>{if(t.key!=="Tab"||!document.body.classList.contains("menu-open"))return;e=Array.from(s.querySelectorAll('a, button, [tabindex="0"]'));const n=e[0],o=e[e.length-1];if(!n||!o)return;t.shiftKey&&document.activeElement===n?(t.preventDefault(),o.focus()):!t.shiftKey&&document.activeElement===o&&(t.preventDefault(),n.focus())},l=()=>{e=Array.from(s.querySelectorAll('a, button, [tabindex="0"]')),e.length&&e[0].focus(),document.addEventListener("keydown",a)},d=()=>{document.removeEventListener("keydown",a)};c(),s.addEventListener("click",e=>{const t=e.target;if(!(t instanceof Element)||!i())return;const s=t.closest("a");if(!s)return;const o=s.closest("li"),a=o&&o.classList.contains("has-submenu");a||n()})})()</script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rust unsafe isnâ€™t a toy â€” itâ€™s a blood oath: 6 YOLO mistakes that will blow up your code</h1><div class=post-description>Donâ€™t treat unsafe like a get-out-of-jail-free card. With practical examples, this article dissects 6 common unsafe pitfalls: silencing the compiler with duct tape, dereferencing random raw pointers, violating borrow rules inside unsafe, reinventing wheels, abusing unsafe impl, and skipping Safety comments â€” helping you build the right risk mindset and usage patterns.</div><div class=post-meta><span title='2025-08-13 00:00:00 +0000 UTC'>August 13, 2025</span>&nbsp;Â·&nbsp;6 min&nbsp;Â·&nbsp;1278 words&nbsp;Â·&nbsp;Rexai Programming&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://rexai.top/tutorials/rust/rust-unsafe-yolo-sao-cao-zuo/>Zh-Cn</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#unsafe-not-a-get-out-of-jail-free-card-but-your-signed-blood-oath aria-label="unsafe: not a get-out-of-jail-free card, but your signed blood oath">unsafe: not a get-out-of-jail-free card, but your signed blood oath</a></li><li><a href=#sin-1-using-unsafe-as-duct-tape-to-silence-the-compiler aria-label="Sin 1: Using unsafe as duct tape to silence the compiler">Sin 1: Using unsafe as duct tape to silence the compiler</a></li><li><a href=#sin-2-holding-a-master-key-and-opening-mystery-boxes aria-label="Sin 2: Holding a master key and opening mystery boxes">Sin 2: Holding a master key and opening mystery boxes</a></li><li><a href=#sin-3-thinking-unsafe-is-a-lawless-zone aria-label="Sin 3: Thinking unsafe is a lawless zone">Sin 3: Thinking unsafe is a lawless zone</a></li><li><a href=#sin-4-reinventing-wheels--square-ones aria-label="Sin 4: Reinventing wheels â€” square ones">Sin 4: Reinventing wheels â€” square ones</a></li><li><a href=#sin-5-im-the-inspector--abusing-unsafe-impl aria-label="Sin 5: â€œIâ€™m the inspectorâ€ â€” abusing unsafe impl">Sin 5: â€œIâ€™m the inspectorâ€ â€” abusing unsafe impl</a></li><li><a href=#sin-6-writing-sacred-scripts--no-comments aria-label="Sin 6: Writing â€œsacred scriptsâ€ â€” no comments">Sin 6: Writing â€œsacred scriptsâ€ â€” no comments</a></li><li><a href=#conclusion-wield-the-dragonslayer-with-reverence aria-label="Conclusion: Wield the dragonslayer with reverence">Conclusion: Wield the dragonslayer with reverence</a></li></ul></div></details></div><div class=post-content><p>Friend, have you had a night like this?</p><p>On the screen, the Rust compilerâ€™s scarlet errors grip your project by the throat. Lifetimes, ownership, borrow rules â€” the guardians youâ€™re usually proud of suddenly feel like a never-ending lecture you just want to shut up.</p><p>Right when youâ€™re about to give up and smash the keyboard, a word glows in your mind with devilish temptation â€” <code>unsafe</code>.</p><p>It feels like a cheat code, a God-mode switch that makes all red squiggles vanish. You wrap those â€œproblematicâ€ lines inside a sacred block, type <code>cargo build</code>â€¦ Success! Silence.</p><p>You breathe out, feeling like a hero who tamed a dragon. But behind the compilerâ€™s silence, thereâ€™s a disdainful glance that says: â€œFine. Play your way â€” but what happens next is on you.â€</p><h2 id=unsafe-not-a-get-out-of-jail-free-card-but-your-signed-blood-oath><code>unsafe</code>: not a get-out-of-jail-free card, but your signed blood oath<a hidden class=anchor aria-hidden=true href=#unsafe-not-a-get-out-of-jail-free-card-but-your-signed-blood-oath>#</a></h2><p>Letâ€™s rip off the free-spirited mask of <code>unsafe</code> and face its brutal truth.</p><p>In Rust, <code>unsafe</code> does not mean â€œturn off all safety checks and YOLO.â€ It truly means:</p><p>â€œMe, the mighty programmer, solemnly swear to personally take responsibility for memory safety in this code region. What the compiler canâ€™t see, I understand; what it canâ€™t check, I guarantee. If the program crashes, leaks, corrupts data â€” even explodes servers or sinks the company â€” I alone will bear it.â€</p><p>Youâ€™re not turning off the rules; youâ€™re signing a waiver. Youâ€™re telling the compiler, â€œIâ€™ve got this region. If it goes south, thatâ€™s on me.â€</p><p>Itâ€™s like disabling the worldâ€™s best ADAS in your car because itâ€™s â€œtoo naggy,â€ then flooring the pedal. Sure, itâ€™s thrilling â€” but whether a cliff or an open road lies ahead depends entirely on your skill and luck.</p><p>Most of us think weâ€™re drift legends. Usually, weâ€™re rookies. To keep you from flying off the mountain road, here are the most common â€œYOLOâ€ misuses of <code>unsafe</code>.</p><hr><h2 id=sin-1-using-unsafe-as-duct-tape-to-silence-the-compiler>Sin 1: Using <code>unsafe</code> as duct tape to silence the compiler<a hidden class=anchor aria-hidden=true href=#sin-1-using-unsafe-as-duct-tape-to-silence-the-compiler>#</a></h2><p>This is the most common â€” and the dumbest â€” mistake. You hit a lifetime or ownership issue, and instead of understanding it, you just slap an <code>unsafe</code> block around it to shut the compiler up.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> r: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> std::mem::transmute(<span style=color:#ae81ff>0x123456</span><span style=color:#66d9ef>usize</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{r}</span><span style=color:#e6db74>&#34;</span>);
</span></span></code></pre></div><p>You coerced an arbitrary memory address <code>0x123456</code> into an <code>&amp;i32</code>. The compiler, gagged by your <code>unsafe</code>, can only watch.</p><p>Consequence: It compiles, then crashes. Or worse â€” it doesnâ€™t crash, but data silently rots. Three months later, a client calls at 3 a.m. and you have no idea where to start.</p><p>Mantra: Every compiler error is like your mom telling you itâ€™s cold outside. She may not be trendy, but sheâ€™s not trying to hurt you. Before you silence the compiler with <code>unsafe</code>, ask: am I really smarter than a system forged by decades of design and collective wisdom?</p><hr><h2 id=sin-2-holding-a-master-key-and-opening-mystery-boxes>Sin 2: Holding a master key and opening mystery boxes<a hidden class=anchor aria-hidden=true href=#sin-2-holding-a-master-key-and-opening-mystery-boxes>#</a></h2><p>Raw pointers are regulars in the <code>unsafe</code> world. They are keys that can point anywhere in memory. Some newcomers get the key and go door-hopping with random addresses.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x123456</span><span style=color:#66d9ef>usize</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>ptr); <span style=color:#75715e>// Guess whatâ€™s in here?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>You assigned a fixed address to <code>ptr</code> and confidently dereferenced it.</p><p>Consequence: This is Russian roulette. That address might be nothing, OS internals, or someone elseâ€™s secrets. Best case: instant crash. Worse: weird, heisenbuggy corruption.</p><p>Mantra: <code>unsafe</code> grants you the right to open a lock â€” but only when youâ€™re 100% sure the lock is your safe, not a munitions depot. Only dereference pointers you created from known-good objects.</p><p>Correct posture:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// Create a pointer from a known, valid value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>x <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// SAFETY: We know ptr points to x, which is alive and valid.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;safe ptr: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>ptr); <span style=color:#75715e>// 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><hr><h2 id=sin-3-thinking-unsafe-is-a-lawless-zone>Sin 3: Thinking <code>unsafe</code> is a lawless zone<a hidden class=anchor aria-hidden=true href=#sin-3-thinking-unsafe-is-a-lawless-zone>#</a></h2><p>Many believe that inside an <code>unsafe</code> block, Rustâ€™s rules vanish and you can do anything.</p><p>No. <code>unsafe</code> is diplomatic immunity for five specific powers. If you violate borrow rules, Rust will still tackle you to the ground.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> v <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>v[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    v.push(<span style=color:#ae81ff>4</span>); <span style=color:#75715e>// Borrow rules still apply
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{x}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Even inside <code>unsafe</code>, this wonâ€™t compile. You tried to hold an immutable borrow (<code>x</code>) and then mutate (<code>v.push(4)</code>) â€” a red line in Rust.</p><p>Mantra: <code>unsafe</code> only allows five things:</p><ol><li>Dereference raw pointers</li><li>Call <code>unsafe</code> or external (FFI) functions</li><li>Access or mutate mutable statics</li><li>Access <code>union</code> fields</li><li>Implement <code>unsafe</code> traits</li></ol><p>For everything else, youâ€™re still a good Rust citizen.</p><hr><h2 id=sin-4-reinventing-wheels--square-ones>Sin 4: Reinventing wheels â€” square ones<a hidden class=anchor aria-hidden=true href=#sin-4-reinventing-wheels--square-ones>#</a></h2><p>When dealing with C libraries or C-strings, you might think, â€œI can write a <code>strlen</code> with <code>unsafe</code>. Cool!â€</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// A manual C-style strlen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>strlen</span>(ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>*</span>ptr.add(len) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        len <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    len
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Looks hackerish, but you likely produced a buggy, slower square wheel.</p><p>Mantra: Before writing <code>unsafe</code>, repeat: â€œAm I reinventing a wheel?â€ Rustâ€™s std and ecosystem already provide safe, battle-tested abstractions for almost everything low-level.</p><p>Correct posture:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::ffi::CStr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c_string_bytes <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;hello</span><span style=color:#ae81ff>\0</span><span style=color:#e6db74>&#34;</span>; <span style=color:#75715e>// Note the trailing \0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> c_str_ptr <span style=color:#f92672>=</span> c_string_bytes.as_ptr() <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>i8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cstr <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// SAFETY: The pointer is valid and points to a NUL-terminated C string.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        CStr::from_ptr(c_str_ptr)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Use the wheel that exists: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, cstr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=sin-5-im-the-inspector--abusing-unsafe-impl>Sin 5: â€œIâ€™m the inspectorâ€ â€” abusing <code>unsafe impl</code><a hidden class=anchor aria-hidden=true href=#sin-5-im-the-inspector--abusing-unsafe-impl>#</a></h2><p>This is one of the most dangerous easy-to-abuse features: <code>unsafe impl</code>.</p><p>When you write <code>unsafe impl Send for MyType {}</code>, youâ€™re swearing to the concurrency gods that <code>MyType</code> can be safely moved across threads â€” no data races, no UB.</p><p>The compiler trusts you completely.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyType</span> {
</span></span><span style=display:flex><span>    ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span>, <span style=color:#75715e>// raw pointer, yikes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>impl</span> Send <span style=color:#66d9ef>for</span> MyType {} <span style=color:#75715e>// boom
</span></span></span></code></pre></div><p>Consequence: You planted a time bomb in your concurrent code. Everything looks fine in single-threaded tests; in production, two threads touch the same raw pointer and now you have races, corruption, crashes â€” ghosts you canâ€™t catch.</p><p>Mantra: <code>unsafe impl Send</code> and <code>unsafe impl Sync</code> are nuclear buttons. Unless youâ€™re writing very low-level concurrency primitives and truly understand the memory model, atomics, and data-race freedom, donâ€™t touch them.</p><p>For 99.99% of cases, use safe primitives like <code>Arc&lt;Mutex&lt;T>></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::{Arc, Mutex};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyType</span> {
</span></span><span style=display:flex><span>    data: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=sin-6-writing-sacred-scripts--no-comments>Sin 6: Writing â€œsacred scriptsâ€ â€” no comments<a hidden class=anchor aria-hidden=true href=#sin-6-writing-sacred-scripts--no-comments>#</a></h2><p><code>unsafe</code> code is hard to reason about because it breaks common mental models. If you write clever (or devious) <code>unsafe</code> without comments, youâ€™re leaving a booby trap for future you.</p><p>Bad:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pointer hackery
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Better:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> data <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> ptr1 <span style=color:#f92672>=</span> data.as_mut_ptr();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> ptr2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { ptr1.add(<span style=color:#ae81ff>2</span>) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// SAFETY: We obtained ptr1 via as_mut_ptr() from a 3-element array.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ptr1.add(2) stays within bounds, so dereferencing ptr2 is valid.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>ptr2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert_eq!</span>(data, [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>]);
</span></span></code></pre></div><p>Every <code>unsafe</code> block must have a Safety comment that explains:</p><ol><li>Why <code>unsafe</code> is required</li><li>What makes it safe in this context</li><li>What invariants the caller must uphold</li></ol><hr><h2 id=conclusion-wield-the-dragonslayer-with-reverence>Conclusion: Wield the dragonslayer with reverence<a hidden class=anchor aria-hidden=true href=#conclusion-wield-the-dragonslayer-with-reverence>#</a></h2><p><code>unsafe</code> is Rustâ€™s ultimate power. It lets you dance with hardware, interop with C/C++, and squeeze the last drop of performance. Itâ€™s a dragonslayer.</p><p>But an irresponsible slayer wreaks more havoc than the dragon.</p><p>Use <code>unsafe</code> with humility:</p><ul><li>Prefer safe code first</li><li>Minimize the scope of <code>unsafe</code></li><li>Wrap it in safe abstractions</li><li>Write a crystal-clear Safety comment for every <code>unsafe</code> block</li></ul><p>Do this, and youâ€™ll master the power â€” not be mastered by it.</p><p>Follow Rexai Programming on WeChat for more deep dives.</p></div><section class=post-actions aria-label="post actions"><div class=post-actions__group><div class=post-actions__item><script type=text/javascript src=https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js data-name=bmc-button data-slug=winbbryz data-color=#FFDD00 data-emoji data-font=Cookie data-text="Buy me a coffee" data-outline-color=#000000 data-font-color=#000000 data-coffee-color=#ffffff></script></div></div></section><footer class=post-footer><ul class=post-tags><li><a href=https://rexai.top/en/tags/rust/>Rust</a></li><li><a href=https://rexai.top/en/tags/unsafe/>Unsafe</a></li><li><a href=https://rexai.top/en/tags/memory-safety/>Memory-Safety</a></li><li><a href=https://rexai.top/en/tags/pointers/>Pointers</a></li><li><a href=https://rexai.top/en/tags/ffi/>FFI</a></li><li><a href=https://rexai.top/en/tags/concurrency/>Concurrency</a></li><li><a href=https://rexai.top/en/tags/best-practices/>Best-Practices</a></li></ul></footer></article></main><footer class=footer><span>Â© <a href=https://rexai.top/>æ¢¦å…½ç¼–ç¨‹</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>