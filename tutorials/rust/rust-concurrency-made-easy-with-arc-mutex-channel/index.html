<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust Concurrency Explained: A Guide to Arc, Mutex, and Channels for Thread Safety | 梦兽编程</title><meta name=keywords content="Rust concurrency,Arc atomic reference counting,Mutex mutual exclusion,Channel communication,thread safety,concurrent programming,Rust tutorial,multithreading"><meta name=description content="Deep dive into Rust's core concurrency concepts: Arc atomic reference counting, Mutex mutual exclusion, and Channel communication. Learn thread-safe concurrent programming through vivid analogies and practical code examples."><meta name=author content="Dream Beast Programming"><link rel=canonical href=https://rexai.top/tutorials/rust/rust-concurrency-made-easy-with-arc-mutex-channel/><link crossorigin=anonymous href=/assets/css/stylesheet.852d08305fd9657bd0c1817a6ba86d4d8a66d40bbd25a67d45a8f93eb25903a1.css integrity="sha256-hS0IMF/ZZXvQwYF6a6htTYpm1Au9JaZ9Raj5PrJZA6E=" rel="preload stylesheet" as=style><link rel=icon href=https://rexai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rexai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rexai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://rexai.top/apple-touch-icon.png><link rel=mask-icon href=https://rexai.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://rexai.top/zh-cn/tutorials/rust/rust-concurrency-made-easy-with-arc-mutex-channel/><link rel=alternate hreflang=en href=https://rexai.top/tutorials/rust/rust-concurrency-made-easy-with-arc-mutex-channel/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.promotion-section{margin-top:2rem;text-align:center}.promotion-section h3{margin-bottom:1.5rem;color:var(--primary);font-size:1.25rem}.qr-codes{display:flex;gap:2rem;justify-content:center;flex-wrap:wrap}.qr-item{text-align:center}.qr-item img{width:150px;height:150px;border:1px solid #ddd;border-radius:8px;padding:8px;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.1);transition:transform .2s}.qr-item img:hover{transform:scale(1.05)}.qr-item p{margin-top:.5rem;font-size:.9rem;color:var(--secondary);font-weight:500}@media(max-width:768px){.qr-codes{flex-direction:column;align-items:center;gap:1rem}.qr-item img{width:120px;height:120px}}</style><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-K6VQRF8T")</script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=winbbryz data-description="Support me on Buy me a coffee!" data-message data-color=#FF813F data-position=Right data-x_margin=18 data-y_margin=18></script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K6VQRF8T" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><meta property="og:url" content="https://rexai.top/tutorials/rust/rust-concurrency-made-easy-with-arc-mutex-channel/"><meta property="og:site_name" content="梦兽编程"><meta property="og:title" content="Rust Concurrency Explained: A Guide to Arc, Mutex, and Channels for Thread Safety"><meta property="og:description" content="Deep dive into Rust's core concurrency concepts: Arc atomic reference counting, Mutex mutual exclusion, and Channel communication. Learn thread-safe concurrent programming through vivid analogies and practical code examples."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2024-01-15T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-15T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Multithreading"><meta property="article:tag" content="Arc"><meta property="article:tag" content="Mutex"><meta property="article:tag" content="Channel"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Concurrency Explained: A Guide to Arc, Mutex, and Channels for Thread Safety"><meta name=twitter:description content="Deep dive into Rust's core concurrency concepts: Arc atomic reference counting, Mutex mutual exclusion, and Channel communication. Learn thread-safe concurrent programming through vivid analogies and practical code examples."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://rexai.top/tutorials/"},{"@type":"ListItem","position":2,"name":"Rust Tutorials","item":"https://rexai.top/tutorials/rust/"},{"@type":"ListItem","position":3,"name":"Rust Concurrency Explained: A Guide to Arc, Mutex, and Channels for Thread Safety","item":"https://rexai.top/tutorials/rust/rust-concurrency-made-easy-with-arc-mutex-channel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Concurrency Explained: A Guide to Arc, Mutex, and Channels for Thread Safety","name":"Rust Concurrency Explained: A Guide to Arc, Mutex, and Channels for Thread Safety","description":"Deep dive into Rust's core concurrency concepts: Arc atomic reference counting, Mutex mutual exclusion, and Channel communication. Learn thread-safe concurrent programming through vivid analogies and practical code examples.","keywords":["Rust concurrency","Arc atomic reference counting","Mutex mutual exclusion","Channel communication","thread safety","concurrent programming","Rust tutorial","multithreading"],"articleBody":"Mastering Rust Concurrency: Arc, Mutex, and Channel - The Three Guardians of Thread Safety Follow Dream Beast Programming WeChat Official Account for humorous Rust learning.\nPersonal website: rexai.top\nHave you ever found yourself pounding your chest in the middle of the night, frustrated by a multithreading bug?\nImagine a chaotic kitchen where several chefs (threads) are cooking simultaneously. They’re fighting over the same knife, modifying the same menu at the same time, and even worse - someone just threw the recipe in the trash while another person runs over trying to follow it. The result? Either fingers get cut or the recipe gets completely messed up, ultimately serving up a “Schrödinger’s dish” - the taste depends entirely on luck.\nThis is concurrent programming in many languages - powerful, but full of chaos and danger. You have to be like a worried mother, setting up roadblocks everywhere (like various locks), constantly reminding yourself not to make mistakes, but if you’re not careful, disaster strikes.\nNow, let’s step into Rust’s kitchen.\nThis kitchen is a bit different. At the entrance stands an extremely strict, even somewhat nagging butler (the Rust compiler). He won’t let you just start cooking randomly, but will point out all potential problems in advance, shouting at you: “Hey! You can’t give that knife to someone else unless you’re sure you’re done with it!” “Hey! That menu is shared, only one person can modify it at a time!”\nThough a bit annoying, the result is: absolute safety. You can put a hundred chefs in this kitchen, and they can work together in perfect order without any accidents.\nThis is the charm of Rust’s concurrent programming: it transfers the “worrying” work from your brain to the compiler. You just need to understand and follow the butler’s few core rules to write safe, efficient “foolproof” concurrent code.\nToday, we’ll break down this “butler’s” rules in plain language.\nRule One: Want to Create Clones? Learn to “Let Go” First In Rust, starting a new thread is like creating a clone of yourself to do work. We use the thread::spawn spell.\nBut this butler (compiler) has a strict rule: you can’t casually lend your tools (data) to your clone, because if you finish using them and destroy the tools, when the clone tries to use them, the program crashes (dangling pointer).\nThe butler requires you to explicitly “gift” them. Use the move keyword to tell him: “I don’t want this thing anymore, I’m giving full authority to my clone!”\nLook at the code:\nuse std::thread; fn main() { let name = String::from(\"Dream Beast Programming\"); let handle = thread::spawn(move || { println!(\"My clone says: Hello, {name}\"); }); // If you uncomment the line below, the butler will immediately slap your hand // println!(\"I say: Hello, {name}\"); handle.join().unwrap(); // Wait for the clone to finish work } See? Once you move the name variable to the clone thread, the original loses ownership of it. It’s like giving your only house key to your roommate - you can no longer enter the door. This seemingly tyrannical rule fundamentally prevents the chaos of “two people trying to open the door with the same key simultaneously.”\nRule Two: Want to Share “Read-Only” Materials? Use the “Atomic” Library Sometimes, we don’t want to completely give things away, but want many clones to be able to “read-only” share some materials, like a shared “cooking guide” for all staff.\nDirect sharing? The butler will jump out to stop you again. Because he doesn’t know who will finish reading first, who will finish last, what if the owner of the materials (main thread) leaves early and burns the guide?\nAt this point, we need a magical tool: Arc, short for “Atomic Reference Counting.”\nDon’t be scared by the name, think of it as a “shared reading room in a library.”\nArc::new(data) puts a piece of material into this reading room. Whenever a clone wants to read this material, they get a reading card, which is Arc::clone(\u0026data). This process is very lightweight, just increasing the count of “current readers.”\nWhen the clone finishes reading and leaves, their reading card automatically becomes invalid (count decreases by one). Until the last reader also leaves, the reading room closes and the material is destroyed.\nuse std::sync::Arc; use std::thread; fn main() { let cooking_guide = Arc::new(vec![\"Step 1: Wash vegetables\", \"Step 2: Cut vegetables\", \"Step 3: Cook\"]); for i in 0..3 { let guide_for_clone = Arc::clone(\u0026cooking_guide); thread::spawn(move || { println!(\"Chef {i} is reading the guide: {:?}\", guide_for_clone); }); } // Wait a bit for the chefs to have time to read thread::sleep(std::time::Duration::from_secs(1)); } Through Arc, we safely achieve “shared read-only” data. Like library rules, you can look, you can copy, but you absolutely cannot scribble on the original.\nRule Three: Want to Modify Shared Data? Enter the “Single VIP Room” Alright, here comes the real challenge. What if multiple clones need to modify the same shared data? Like a bank account balance.\nIf everyone goes at it together, you add 100, I subtract 50, the CPU goes wild, and in the end, what the balance becomes depends entirely on fate. This is the evil “data race.”\nRust’s butler absolutely detests this. He has prepared another powerful weapon for you: Mutex, short for “Mutual Exclusion.”\nThink of it as a “single VIP room” containing the shared data we need to modify. This room has only one key.\nWhen a clone wants to modify the data, they must first get the key, which is calling the .lock() method. Once they get the key and enter the room, the door locks, and anyone else who wants to come in has to wait in line outside.\nWhen they finish modifying and leave the room (exit the scope), the key is automatically returned. At this point, the next person in line can get the key and go in.\nThis way, no matter how many people want to modify, at any given time, only one person can succeed. The “atomicity” of data modification is absolutely guaranteed.\nHowever, Mutex itself cannot be directly passed between threads. It needs to team up with our old friend Arc.\nUltimate Combination: Arc + Mutex = Thread-Safe Shared Modification Arc","wordCount":"1627","inLanguage":"en","datePublished":"2024-01-15T00:00:00Z","dateModified":"2024-01-15T00:00:00Z","author":{"@type":"Person","name":"Dream Beast Programming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rexai.top/tutorials/rust/rust-concurrency-made-easy-with-arc-mutex-channel/"},"publisher":{"@type":"Organization","name":"梦兽编程","logo":{"@type":"ImageObject","url":"https://rexai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rexai.top/ accesskey=h title="梦兽编程 (Alt + H)">梦兽编程</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://rexai.top/zh-cn/ title=中文 aria-label=中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://rexai.top/ title=Home><span>Home</span></a></li><li class=has-submenu><a href=https://rexai.top/tutorials/ title="📚 Tutorials"><span>📚 Tutorials</span>
<span class=submenu-toggle>▼</span></a><ul class=submenu><li><a href=https://rexai.top/tutorials/rust/ title=Rust>Rust</a></li><li><a href=https://rexai.top/tutorials/ai/ title="AI Programming">AI Programming</a></li></ul></li><li><a href=https://rexai.top/tools/ title=Tools><span>Tools</span></a></li><li><a href=https://rexai.top/news/ title="🔥 News"><span>🔥 News</span></a></li><li><a href=https://rexai.top/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=https://rexai.top/categories/ title="📂 Categories"><span>📂 Categories</span></a></li></ul></nav></header><style>.has-submenu{position:relative}#menu{overflow:visible !important}#menu li{overflow:visible}.submenu{position:absolute;top:100%;left:0;background:var(--theme);border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);min-width:180px;z-index:1000;list-style:none;display:none;padding:.5rem 0}.submenu li{display:block;margin:0;line-height:1.5}#menu .submenu li+li{margin-inline-start:0}.submenu a{display:block;padding:.75rem 1rem;color:var(--secondary);text-decoration:none;transition:all .2s ease;border-radius:0}.submenu a:hover{background:var(--entry);color:var(--primary)}.has-submenu:hover .submenu{display:block !important}.submenu-toggle{margin-left:.25rem;font-size:.75rem;transition:transform .2s ease;display:inline-block}.has-submenu:hover .submenu-toggle{transform:rotate(180deg)}@media(max-width:768px){.submenu{position:static;box-shadow:none;border:none;background:var(--entry);margin-top:0;margin-left:1rem;display:none;padding:0}.has-submenu.active .submenu{display:block}.submenu-toggle{cursor:pointer}}</style><script>window.innerWidth<=768&&document.querySelectorAll(".has-submenu").forEach(e=>{const n=e.querySelector("a"),t=e.querySelector(".submenu-toggle");t&&(t.addEventListener("click",function(t){t.preventDefault(),e.classList.toggle("active")}),n.addEventListener("click",function(t){e.classList.contains("has-submenu")&&(t.preventDefault(),e.classList.toggle("active"))}))})</script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rust Concurrency Explained: A Guide to Arc, Mutex, and Channels for Thread Safety</h1><div class=post-description>Deep dive into Rust's core concurrency concepts: Arc atomic reference counting, Mutex mutual exclusion, and Channel communication. Learn thread-safe concurrent programming through vivid analogies and practical code examples.</div><div class=post-meta><span title='2024-01-15 00:00:00 +0000 UTC'>January 15, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1627 words&nbsp;·&nbsp;Dream Beast Programming&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://rexai.top/zh-cn/tutorials/rust/rust-concurrency-made-easy-with-arc-mutex-channel/>Zh-Cn</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#mastering-rust-concurrency-arc-mutex-and-channel---the-three-guardians-of-thread-safety aria-label="Mastering Rust Concurrency: Arc, Mutex, and Channel - The Three Guardians of Thread Safety">Mastering Rust Concurrency: Arc, Mutex, and Channel - The Three Guardians of Thread Safety</a><ul><li><a href=#rule-one-want-to-create-clones-learn-to aria-label="Rule One: Want to Create Clones? Learn to &ldquo;Let Go&rdquo; First">Rule One: Want to Create Clones? Learn to &ldquo;Let Go&rdquo; First</a></li><li><a href=#rule-two-want-to-share aria-label="Rule Two: Want to Share &ldquo;Read-Only&rdquo; Materials? Use the &ldquo;Atomic&rdquo; Library">Rule Two: Want to Share &ldquo;Read-Only&rdquo; Materials? Use the &ldquo;Atomic&rdquo; Library</a></li><li><a href=#rule-three-want-to-modify-shared-data-enter-the aria-label="Rule Three: Want to Modify Shared Data? Enter the &ldquo;Single VIP Room&rdquo;">Rule Three: Want to Modify Shared Data? Enter the &ldquo;Single VIP Room&rdquo;</a></li><li><a href=#ultimate-combination-arc--mutex--thread-safe-shared-modification aria-label="Ultimate Combination: Arc + Mutex = Thread-Safe Shared Modification">Ultimate Combination: Arc + Mutex = Thread-Safe Shared Modification</a></li><li><a href=#rule-four-don aria-label="Rule Four: Don&rsquo;t Want Shared State? Try the &ldquo;Dedicated Messenger&rdquo;">Rule Four: Don&rsquo;t Want Shared State? Try the &ldquo;Dedicated Messenger&rdquo;</a></li><li><a href=#summary-embrace-the aria-label="Summary: Embrace the &ldquo;Nagging&rdquo; for Peace of Mind">Summary: Embrace the &ldquo;Nagging&rdquo; for Peace of Mind</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=mastering-rust-concurrency-arc-mutex-and-channel---the-three-guardians-of-thread-safety>Mastering Rust Concurrency: Arc, Mutex, and Channel - The Three Guardians of Thread Safety<a hidden class=anchor aria-hidden=true href=#mastering-rust-concurrency-arc-mutex-and-channel---the-three-guardians-of-thread-safety>#</a></h1><p><strong>Follow Dream Beast Programming WeChat Official Account for humorous Rust learning.</strong></p><p>Personal website: rexai.top</p><p>Have you ever found yourself pounding your chest in the middle of the night, frustrated by a multithreading bug?</p><p>Imagine a chaotic kitchen where several chefs (threads) are cooking simultaneously. They&rsquo;re fighting over the same knife, modifying the same menu at the same time, and even worse - someone just threw the recipe in the trash while another person runs over trying to follow it. The result? Either fingers get cut or the recipe gets completely messed up, ultimately serving up a &ldquo;Schrödinger&rsquo;s dish&rdquo; - the taste depends entirely on luck.</p><p>This is concurrent programming in many languages - powerful, but full of chaos and danger. You have to be like a worried mother, setting up roadblocks everywhere (like various locks), constantly reminding yourself not to make mistakes, but if you&rsquo;re not careful, disaster strikes.</p><p>Now, let&rsquo;s step into Rust&rsquo;s kitchen.</p><p>This kitchen is a bit different. At the entrance stands an extremely strict, even somewhat nagging butler (the Rust compiler). He won&rsquo;t let you just start cooking randomly, but will point out all potential problems in advance, shouting at you: &ldquo;Hey! You can&rsquo;t give that knife to someone else unless you&rsquo;re sure you&rsquo;re done with it!&rdquo; &ldquo;Hey! That menu is shared, only one person can modify it at a time!&rdquo;</p><p>Though a bit annoying, the result is: absolute safety. You can put a hundred chefs in this kitchen, and they can work together in perfect order without any accidents.</p><p>This is the charm of Rust&rsquo;s concurrent programming: it transfers the &ldquo;worrying&rdquo; work from your brain to the compiler. You just need to understand and follow the butler&rsquo;s few core rules to write safe, efficient &ldquo;foolproof&rdquo; concurrent code.</p><p>Today, we&rsquo;ll break down this &ldquo;butler&rsquo;s&rdquo; rules in plain language.</p><h2 id=rule-one-want-to-create-clones-learn-to><strong>Rule One: Want to Create Clones? Learn to &ldquo;Let Go&rdquo; First</strong><a hidden class=anchor aria-hidden=true href=#rule-one-want-to-create-clones-learn-to>#</a></h2><p>In Rust, starting a new thread is like creating a clone of yourself to do work. We use the <code>thread::spawn</code> spell.</p><p>But this butler (compiler) has a strict rule: you can&rsquo;t casually lend your tools (data) to your clone, because if you finish using them and destroy the tools, when the clone tries to use them, the program crashes (dangling pointer).</p><p>The butler requires you to explicitly &ldquo;gift&rdquo; them. Use the <code>move</code> keyword to tell him: &ldquo;I don&rsquo;t want this thing anymore, I&rsquo;m giving full authority to my clone!&rdquo;</p><p>Look at the code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Dream Beast Programming&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;My clone says: Hello, </span><span style=color:#e6db74>{name}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If you uncomment the line below, the butler will immediately slap your hand
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// println!(&#34;I say: Hello, {name}&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    handle.join().unwrap(); <span style=color:#75715e>// Wait for the clone to finish work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>See? Once you <code>move</code> the <code>name</code> variable to the clone thread, the original loses ownership of it. It&rsquo;s like giving your only house key to your roommate - you can no longer enter the door. This seemingly tyrannical rule fundamentally prevents the chaos of &ldquo;two people trying to open the door with the same key simultaneously.&rdquo;</p><h2 id=rule-two-want-to-share><strong>Rule Two: Want to Share &ldquo;Read-Only&rdquo; Materials? Use the &ldquo;Atomic&rdquo; Library</strong><a hidden class=anchor aria-hidden=true href=#rule-two-want-to-share>#</a></h2><p>Sometimes, we don&rsquo;t want to completely give things away, but want many clones to be able to &ldquo;read-only&rdquo; share some materials, like a shared &ldquo;cooking guide&rdquo; for all staff.</p><p>Direct sharing? The butler will jump out to stop you again. Because he doesn&rsquo;t know who will finish reading first, who will finish last, what if the owner of the materials (main thread) leaves early and burns the guide?</p><p>At this point, we need a magical tool: <code>Arc&lt;T></code>, short for &ldquo;Atomic Reference Counting.&rdquo;</p><p>Don&rsquo;t be scared by the name, think of it as a &ldquo;shared reading room in a library.&rdquo;</p><p><code>Arc::new(data)</code> puts a piece of material into this reading room. Whenever a clone wants to read this material, they get a reading card, which is <code>Arc::clone(&amp;data)</code>. This process is very lightweight, just increasing the count of &ldquo;current readers.&rdquo;</p><p>When the clone finishes reading and leaves, their reading card automatically becomes invalid (count decreases by one). Until the last reader also leaves, the reading room closes and the material is destroyed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::Arc;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cooking_guide <span style=color:#f92672>=</span> Arc::new(<span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;Step 1: Wash vegetables&#34;</span>, <span style=color:#e6db74>&#34;Step 2: Cut vegetables&#34;</span>, <span style=color:#e6db74>&#34;Step 3: Cook&#34;</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> guide_for_clone <span style=color:#f92672>=</span> Arc::clone(<span style=color:#f92672>&amp;</span>cooking_guide);
</span></span><span style=display:flex><span>        thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Chef </span><span style=color:#e6db74>{i}</span><span style=color:#e6db74> is reading the guide: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, guide_for_clone);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wait a bit for the chefs to have time to read
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    thread::sleep(std::time::Duration::from_secs(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Through <code>Arc</code>, we safely achieve &ldquo;shared read-only&rdquo; data. Like library rules, you can look, you can copy, but you absolutely cannot scribble on the original.</p><h2 id=rule-three-want-to-modify-shared-data-enter-the><strong>Rule Three: Want to Modify Shared Data? Enter the &ldquo;Single VIP Room&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#rule-three-want-to-modify-shared-data-enter-the>#</a></h2><p>Alright, here comes the real challenge. What if multiple clones need to modify the same shared data? Like a bank account balance.</p><p>If everyone goes at it together, you add 100, I subtract 50, the CPU goes wild, and in the end, what the balance becomes depends entirely on fate. This is the evil &ldquo;data race.&rdquo;</p><p>Rust&rsquo;s butler absolutely detests this. He has prepared another powerful weapon for you: <code>Mutex&lt;T></code>, short for &ldquo;Mutual Exclusion.&rdquo;</p><p>Think of it as a &ldquo;single VIP room&rdquo; containing the shared data we need to modify. This room has only one key.</p><p>When a clone wants to modify the data, they must first get the key, which is calling the <code>.lock()</code> method. Once they get the key and enter the room, the door locks, and anyone else who wants to come in has to wait in line outside.</p><p>When they finish modifying and leave the room (exit the scope), the key is automatically returned. At this point, the next person in line can get the key and go in.</p><p>This way, no matter how many people want to modify, at any given time, only one person can succeed. The &ldquo;atomicity&rdquo; of data modification is absolutely guaranteed.</p><p>However, <code>Mutex</code> itself cannot be directly passed between threads. It needs to team up with our old friend <code>Arc</code>.</p><h2 id=ultimate-combination-arc--mutex--thread-safe-shared-modification><strong>Ultimate Combination: Arc + Mutex = Thread-Safe Shared Modification</strong><a hidden class=anchor aria-hidden=true href=#ultimate-combination-arc--mutex--thread-safe-shared-modification>#</a></h2><p><code>Arc&lt;Mutex&lt;T>></code> is the most common and powerful combination in Rust concurrent programming.</p><p><code>Arc</code> is responsible for making the &ldquo;key&rdquo; to this &ldquo;single VIP room&rdquo; safely visible and obtainable by all clones.
<code>Mutex</code> is responsible for ensuring that even though all clones can get the key, only one person can enter the room at a time.</p><p>Let&rsquo;s look at a classic counter example: 10 clones, each wanting to increment the counter by 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::{Arc, Mutex};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Put a counter with initial value 0 into a single room (Mutex), then put the key distributor for this room into the library (Arc)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> counter <span style=color:#f92672>=</span> Arc::new(Mutex::new(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> handles <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> counter_clone <span style=color:#f92672>=</span> Arc::clone(<span style=color:#f92672>&amp;</span>counter);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Want to modify data? Get the key and enter the room first!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> num <span style=color:#f92672>=</span> counter_clone.lock().unwrap();
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>num <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Leave the room, key automatically returned
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        });
</span></span><span style=display:flex><span>        handles.push(handle);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wait for all clones to finish work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> handle <span style=color:#66d9ef>in</span> handles {
</span></span><span style=display:flex><span>        handle.join().unwrap();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Finally, we get the key ourselves and go in to see the result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Final result: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>counter.lock().unwrap());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The final result will be exactly 10! This is the power of <code>Arc&lt;Mutex&lt;T>></code>. It uses a seemingly cumbersome method to achieve 100% peace of mind.</p><h2 id=rule-four-don><strong>Rule Four: Don&rsquo;t Want Shared State? Try the &ldquo;Dedicated Messenger&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#rule-four-don>#</a></h2><p>Sometimes, sharing memory and locks between threads is still too troublesome, like chefs crowding around one workstation. A better approach is for each chef to have their own independent workstation, with semi-finished products sent to the next chef through a dedicated conveyor belt (Channel).</p><p>This is the &ldquo;Channel&rdquo; mechanism, a way to communicate through message passing rather than shared memory.</p><p>In Rust, we use <code>mpsc::channel</code> to create a channel. <code>mpsc</code> means &ldquo;Multiple Producer, Single Consumer.&rdquo; Like a post office, many people (producers) can send letters to one mailbox (consumer).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::mpsc;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a channel, tx is the sender (transmitter), rx is the receiver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> (tx, rx) <span style=color:#f92672>=</span> mpsc::channel();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The clone creates a package and sends it through the sender tx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        tx.send(<span style=color:#e6db74>&#34;A package from the future&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The main thread waits at the receiver rx, recv() will wait until the package arrives
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> received <span style=color:#f92672>=</span> rx.recv().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Received package: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, received);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This approach makes collaboration between threads very decoupled and clear. You do your thing, I do mine, and when we need to communicate, we just send a message. This aligns with Rust&rsquo;s philosophy: &ldquo;Don&rsquo;t communicate through shared memory, share memory through communication.&rdquo;</p><h2 id=summary-embrace-the><strong>Summary: Embrace the &ldquo;Nagging&rdquo; for Peace of Mind</strong><a hidden class=anchor aria-hidden=true href=#summary-embrace-the>#</a></h2><p>Let&rsquo;s review the four major rules of Rust&rsquo;s kitchen:</p><ol><li><strong><code>move</code></strong>: If you want your clone to work, you must completely transfer ownership of the tools.</li><li><strong><code>Arc&lt;T></code></strong>: If you want everyone to read materials together, put them in the &ldquo;shared reading room.&rdquo;</li><li><strong><code>Arc&lt;Mutex&lt;T>></code></strong>: If you want everyone to modify things together, lock them in the &ldquo;single VIP room&rdquo; and share the key distributor.</li><li><strong><code>channel</code></strong>: If you don&rsquo;t want to crowd together, give them dedicated &ldquo;message conveyor belts.&rdquo;</li></ol><p>Rust&rsquo;s concurrency model is fundamentally about its ownership system. The compiler, this strict butler, helps you avoid all possible runtime chaos by enforcing these seemingly rigid rules at compile time.</p><p>At first, you might find him annoying and restrictive. But when you truly experience that peace of mind - never worrying about data races, never fearing concurrent bugs - you&rsquo;ll understand this butler&rsquo;s good intentions. You&rsquo;ll sincerely exclaim:</p><p>&ldquo;Delicious!&rdquo;</p><hr><p><strong>Follow Dream Beast Programming WeChat Official Account to unlock more cutting-edge tech.</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rexai.top/tags/rust/>Rust</a></li><li><a href=https://rexai.top/tags/concurrency/>Concurrency</a></li><li><a href=https://rexai.top/tags/multithreading/>Multithreading</a></li><li><a href=https://rexai.top/tags/arc/>Arc</a></li><li><a href=https://rexai.top/tags/mutex/>Mutex</a></li><li><a href=https://rexai.top/tags/channel/>Channel</a></li><li><a href=https://rexai.top/tags/tutorial/>Tutorial</a></li></ul></footer></article></main><footer class=footer><span>© <a href=https://rexai.top/>梦兽编程</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>