<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust Ultimate Guide: 5 Trait & Generic Pitfalls That Will Make Your Colleagues 'Unreachable' | 梦兽编程</title><meta name=keywords content="Rust,Traits,Generics,Rust Programming,Rust Tutorial,Rust Best Practices,Rust Pitfalls,Rust Errors,Rust Performance Optimization,Rust Learning"><meta name=description content="Deep dive into 5 common Rust Traits and Generics pitfalls, from generic overuse, trait constraint chaos, static vs dynamic dispatch confusion, associated types usage to struct constraint abuse. Master elegant and efficient Rust code."><meta name=author content="Dream Beast Programming"><link rel=canonical href=https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/><link crossorigin=anonymous href=/assets/css/stylesheet.852d08305fd9657bd0c1817a6ba86d4d8a66d40bbd25a67d45a8f93eb25903a1.css integrity="sha256-hS0IMF/ZZXvQwYF6a6htTYpm1Au9JaZ9Raj5PrJZA6E=" rel="preload stylesheet" as=style><link rel=icon href=https://rexai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rexai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rexai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://rexai.top/apple-touch-icon.png><link rel=mask-icon href=https://rexai.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://rexai.top/zh-cn/tutorials/rust/rust-traits-and-generics-common-mistakes/><link rel=alternate hreflang=en href=https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.promotion-section{margin-top:2rem;text-align:center}.promotion-section h3{margin-bottom:1.5rem;color:var(--primary);font-size:1.25rem}.qr-codes{display:flex;gap:2rem;justify-content:center;flex-wrap:wrap}.qr-item{text-align:center}.qr-item img{width:150px;height:150px;border:1px solid #ddd;border-radius:8px;padding:8px;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.1);transition:transform .2s}.qr-item img:hover{transform:scale(1.05)}.qr-item p{margin-top:.5rem;font-size:.9rem;color:var(--secondary);font-weight:500}@media(max-width:768px){.qr-codes{flex-direction:column;align-items:center;gap:1rem}.qr-item img{width:120px;height:120px}}</style><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-K6VQRF8T")</script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=winbbryz data-description="Support me on Buy me a coffee!" data-message data-color=#FF813F data-position=Right data-x_margin=18 data-y_margin=18></script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K6VQRF8T" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><meta property="og:url" content="https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/"><meta property="og:site_name" content="梦兽编程"><meta property="og:title" content="Rust Ultimate Guide: 5 Trait & Generic Pitfalls That Will Make Your Colleagues 'Unreachable'"><meta property="og:description" content="Deep dive into 5 common Rust Traits and Generics pitfalls, from generic overuse, trait constraint chaos, static vs dynamic dispatch confusion, associated types usage to struct constraint abuse. Master elegant and efficient Rust code."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2025-01-27T10:00:00+08:00"><meta property="article:modified_time" content="2025-01-27T10:00:00+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Traits"><meta property="article:tag" content="Generics"><meta property="article:tag" content="Programming Tutorial"><meta property="article:tag" content="Best Practices"><meta property="article:tag" content="Performance Optimization"><meta property="og:image" content="https://rexai.top/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rexai.top/cover.png"><meta name=twitter:title content="Rust Ultimate Guide: 5 Trait & Generic Pitfalls That Will Make Your Colleagues 'Unreachable'"><meta name=twitter:description content="Deep dive into 5 common Rust Traits and Generics pitfalls, from generic overuse, trait constraint chaos, static vs dynamic dispatch confusion, associated types usage to struct constraint abuse. Master elegant and efficient Rust code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://rexai.top/tutorials/"},{"@type":"ListItem","position":2,"name":"Rust Tutorials","item":"https://rexai.top/tutorials/rust/"},{"@type":"ListItem","position":3,"name":"Rust Ultimate Guide: 5 Trait \u0026 Generic Pitfalls That Will Make Your Colleagues 'Unreachable'","item":"https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Ultimate Guide: 5 Trait \u0026 Generic Pitfalls That Will Make Your Colleagues 'Unreachable'","name":"Rust Ultimate Guide: 5 Trait \u0026 Generic Pitfalls That Will Make Your Colleagues \u0027Unreachable\u0027","description":"Deep dive into 5 common Rust Traits and Generics pitfalls, from generic overuse, trait constraint chaos, static vs dynamic dispatch confusion, associated types usage to struct constraint abuse. Master elegant and efficient Rust code.","keywords":["Rust","Traits","Generics","Rust Programming","Rust Tutorial","Rust Best Practices","Rust Pitfalls","Rust Errors","Rust Performance Optimization","Rust Learning"],"articleBody":"Rust Ultimate Guide: 5 Trait \u0026 Generic Pitfalls That Will Make Your Colleagues ‘Unreachable’ Follow Dream Beast Programming WeChat Official Account for humorous Rust learning\nHello, brave Rustacean!\nHave you ever been “ground to dust” by Rust’s compiler? Facing a screen full of cryptic error messages, wondering if you chose the wrong programming language? Don’t worry, you’re not alone in this battle.\nRust’s most powerful weapon is its “zero-cost abstraction” capability. The core secret of this martial art is Traits, Generics, and Where clauses. Used correctly, your code will be as elegant as poetry and as fast as an F1 race car.\nBut… what if you use them wrong? They instantly become a pot of “spaghetti” that makes your scalp tingle, with compilation errors that could circle the Earth three times, enough to scare any programming novice into uninstalling Rust overnight.\nToday I’ll reveal and fill in those most common Trait and Generic “pitfalls”. Buckle up, let’s go!\nPitfall #1: Using a Dragon Slayer Sword to Cut Vegetables — Unnecessary Generic Overuse Imagine you have a sword that can cut through iron like mud, but you use it every day to slice potatoes. Isn’t that a bit overkill?\nThe mistake you might be making:\n// Looks fine, right? fn print_value\u003cT: std::fmt::Debug\u003e(value: T) { println!(\"{:?}\", value); } Technically, this code runs. But the problem is, if throughout your entire project, you’re only ever passing an i32 type to this function, why are you using generics?\nYou’re adding unnecessary complexity for flexibility that doesn’t exist. The compiler needs to perform “monomorphization” for each concrete type, generating additional code. It’s like renovating all your rooms to five-star presidential suite standards just in case you might occasionally host a king, but the only visitor is always your neighbor Lao Wang.\nThe wiser approach:\n// Simple but efficient fn print_value(value: i32) { println!(\"{:?}\", value); } My divine mantra: Remember, generics are your superpower, but don’t show off your muscles too early. Only summon the “dragon” of generics when you truly need to handle multiple types. Otherwise, starting with concrete types is always the most efficient and clearest choice.\nPitfall #2: Code “Spaghetti” — Chaotic Trait Constraints When your function needs more than one generic parameter, and each parameter comes with a bunch of constraints, your function signature quickly becomes an incomprehensible bowl of “spaghetti”.\nThe mistake you might be making:\n// One parameter is okay, but try two? fn log_json\u003cT: serde::Serialize + std::fmt::Debug + Clone\u003e(item: T) { // ... } As constraints multiply, the content inside angle brackets \u003c\u003e gets longer and longer, readability plummets, and maintenance becomes a nightmare.\nThe wiser approach: Let where clauses save you!\nwhere clauses are like professional librarians who neatly organize all the messy constraint conditions, making your function signatures as refreshing as a summer breeze.\n// Using where makes the code instantly clean fn log_json\u003cT\u003e(item: T) where T: serde::Serialize + std::fmt::Debug + Clone, { // ... } // Multiple parameters? Piece of cake! fn process_data\u003cT, U\u003e(a: T, b: U) where T: Clone + std::fmt::Debug, U: Default + std::fmt::Debug, { // ... } My divine mantra: Liberate constraint conditions from angle brackets and let where clauses manage them. This isn’t just a style issue; it’s the lifeline of code readability and maintainability.\nPitfall #3: Confusing “Static” with “Dynamic” — Mixing Generics with Trait Objects This is the pit that newcomers fall into most easily. Generics and trait objects (dyn Trait) can both achieve polymorphism, but their application scenarios are completely different.\nGenerics: Static dispatch. At compile time, the compiler knows all concrete types and generates code for each type. Fast, but not flexible enough; you can’t store instances of different types in one collection. Trait objects (\u0026dyn Trait): Dynamic dispatch. At runtime, methods are called through virtual function tables (vtables). Slightly slower (almost negligible), but extremely flexible, allowing you to create heterogeneous collections (like a list containing cats, dogs, and birds). The mistake you might be making:\nYou want to create a function that can accept anything that can “draw” itself, so you write a generic version:\ntrait Drawable { fn draw(\u0026self); } // This function can only accept one specific Drawable type at a time // You can't pass it a list containing both Circle and Square fn draw_static\u003cT: Drawable\u003e(item: T) { item.draw(); } The wiser approach: Embrace dyn Trait when you need heterogeneous collections\n// Using trait objects, accepts any type that implements Drawable fn draw_dynamic(item: \u0026dyn Drawable) { item.draw(); } // Ultimate usage: render a scene containing various shapes fn render_scene(items: Vec\u003cBox\u003cdyn Drawable\u003e\u003e) { for item in items { item.draw(); } } My divine mantra: Simple rule: When you need a function or struct to determine types at compile time, pursuing ultimate performance, use generics. When you need to handle a collection containing multiple different types (but all implementing the same trait) at runtime, don’t hesitate to use trait objects. This is the correct way to open “duck typing” in Rust.\nPitfall #4: Messing Up the Trait “Family” — Not Using Associated Types, Self-inflicted Trouble When multiple methods within a trait depend on the same “auxiliary type”, using generics makes things extremely awkward.\nThe mistake you might be making:\n// Using generics to define stored item types, too verbose! trait Storage\u003cT\u003e { fn save(\u0026self, item: T); fn load(\u0026self) -\u003e T; } This approach becomes very awkward when implementing (impl), because you need to drag that generic T everywhere.\nThe wiser approach: Use Associated Types\nAssociated types make your traits more “cohesive” and clear. It’s like saying: “Any type that implements my Storage trait must internally specify an Item type that it stores.”\ntrait Storage { type Item; // Define associated type here fn save(\u0026self, item: Self::Item); fn load(\u0026self) -\u003e Self::Item; } // Implementation is so clean! struct MemoryStorage; impl Storage for MemoryStorage { type Item = String; // Directly specify concrete type here fn save(\u0026self, item: String) { /* ... */ } fn load(\u0026self) -\u003e String { /* ... */ } } My divine mantra: When a type in a trait is strongly related to the type implementing that trait, please use associated types. They can greatly simplify APIs and make your trait design more elegant.\nPitfall #5: Premature “Commitment” — Abusing Constraints on Structs This is a very subtle but far-reaching bad habit.\nThe mistake you might be making:\n// Adding Display constraint when defining the struct struct Wrapper\u003cT: std::fmt::Display\u003e { value: T, } Here’s the problem: This means you can’t even create a Wrapper instance unless the T type inside it implements the Display trait—even if you don’t plan to print it anytime soon! This constraint is too domineering.\nThe wiser approach: Only add constraints when needed\nMove constraints from struct definitions to impl blocks or methods that truly need them.\n// The struct itself has no constraints struct Wrapper\u003cT\u003e { value: T, } // Only add Display constraint on the show method that needs printing impl\u003cT: std::fmt::Display\u003e Wrapper\u003cT\u003e { fn show(\u0026self) { println!(\"{}\", self.value); } } My divine mantra: Give your structs maximum freedom. Don’t “lock them down” with trait constraints at definition time. Only make your demands in specific method implementations (impl). This is the essence of the “principle of least privilege”.\nConclusion: From “Pitfalls” to “Highways” Congratulations! You’ve successfully navigated around these five most dangerous “pitfalls”!\nTraits and generics are the dragon-slaying skills that Rust has bestowed upon you. They are powerful and flexible, but they also require wisdom and discipline to master. Remember what you learned today:\nFrom concrete to abstract, don’t abuse generics. Use where to “clean” your code signatures. Distinguish static from dynamic, make correct choices between generics and dyn Trait. Embrace associated types, design clearer traits. Let constraints be “just right”, don’t prematurely limit your structs. Mastering these will elevate your Rust code to a whole new level, and the compiler will become your closest friend, not your enemy.\nWant to unlock more black tech that will boost your skills?\nFollow Dream Beast Programming WeChat Official Account for more black tech.\n","wordCount":"1334","inLanguage":"en","image":"https://rexai.top/cover.png","datePublished":"2025-01-27T10:00:00+08:00","dateModified":"2025-01-27T10:00:00+08:00","author":{"@type":"Person","name":"Dream Beast Programming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/"},"publisher":{"@type":"Organization","name":"梦兽编程","logo":{"@type":"ImageObject","url":"https://rexai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rexai.top/ accesskey=h title="梦兽编程 (Alt + H)">梦兽编程</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://rexai.top/zh-cn/ title=中文 aria-label=中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://rexai.top/ title=Home><span>Home</span></a></li><li class=has-submenu><a href=https://rexai.top/tutorials/ title="📚 Tutorials"><span>📚 Tutorials</span>
<span class=submenu-toggle>▼</span></a><ul class=submenu><li><a href=https://rexai.top/tutorials/rust/ title=Rust>Rust</a></li><li><a href=https://rexai.top/tutorials/ai/ title="AI Programming">AI Programming</a></li></ul></li><li><a href=https://rexai.top/tools/ title=Tools><span>Tools</span></a></li><li><a href=https://rexai.top/news/ title="🔥 News"><span>🔥 News</span></a></li><li><a href=https://rexai.top/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=https://rexai.top/categories/ title="📂 Categories"><span>📂 Categories</span></a></li></ul></nav></header><style>.has-submenu{position:relative}#menu{overflow:visible !important}#menu li{overflow:visible}.submenu{position:absolute;top:100%;left:0;background:var(--theme);border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);min-width:180px;z-index:1000;list-style:none;display:none;padding:.5rem 0}.submenu li{display:block;margin:0;line-height:1.5}#menu .submenu li+li{margin-inline-start:0}.submenu a{display:block;padding:.75rem 1rem;color:var(--secondary);text-decoration:none;transition:all .2s ease;border-radius:0}.submenu a:hover{background:var(--entry);color:var(--primary)}.has-submenu:hover .submenu{display:block !important}.submenu-toggle{margin-left:.25rem;font-size:.75rem;transition:transform .2s ease;display:inline-block}.has-submenu:hover .submenu-toggle{transform:rotate(180deg)}@media(max-width:768px){.submenu{position:static;box-shadow:none;border:none;background:var(--entry);margin-top:0;margin-left:1rem;display:none;padding:0}.has-submenu.active .submenu{display:block}.submenu-toggle{cursor:pointer}}</style><script>window.innerWidth<=768&&document.querySelectorAll(".has-submenu").forEach(e=>{const n=e.querySelector("a"),t=e.querySelector(".submenu-toggle");t&&(t.addEventListener("click",function(t){t.preventDefault(),e.classList.toggle("active")}),n.addEventListener("click",function(t){e.classList.contains("has-submenu")&&(t.preventDefault(),e.classList.toggle("active"))}))})</script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rust Ultimate Guide: 5 Trait & Generic Pitfalls That Will Make Your Colleagues 'Unreachable'</h1><div class=post-description>Deep dive into 5 common Rust Traits and Generics pitfalls, from generic overuse, trait constraint chaos, static vs dynamic dispatch confusion, associated types usage to struct constraint abuse. Master elegant and efficient Rust code.</div><div class=post-meta><span title='2025-01-27 10:00:00 +0800 +0800'>January 27, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1334 words&nbsp;·&nbsp;Dream Beast Programming&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://rexai.top/zh-cn/tutorials/rust/rust-traits-and-generics-common-mistakes/>Zh-Cn</a></li></ul></div></header><figure class=entry-cover><img loading=eager srcset='https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/cover_hu_ab6eb6a7812b3c2b.png 360w,https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/cover_hu_eaa828f4cab07743.png 480w,https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/cover_hu_e3898d310e90f07c.png 720w,https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/cover_hu_e3b7c00a561315f1.png 1080w,https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/cover_hu_98e4b9067ab49466.png 1500w,https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/cover.png 2163w' src=https://rexai.top/tutorials/rust/rust-traits-and-generics-common-mistakes/cover.png sizes="(min-width: 768px) 720px, 100vw" width=2163 height=1441 alt="Rust Traits and Generics Common Pitfalls Guide"><figcaption>Rust Ultimate Guide: Master the Correct Usage of Traits and Generics</figcaption></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#rust-ultimate-guide-5-trait--generic-pitfalls-that-will-make-your-colleagues-unreachable aria-label="Rust Ultimate Guide: 5 Trait & Generic Pitfalls That Will Make Your Colleagues &lsquo;Unreachable&rsquo;">Rust Ultimate Guide: 5 Trait & Generic Pitfalls That Will Make Your Colleagues &lsquo;Unreachable&rsquo;</a><ul><li><a href=#pitfall-1-using-a-dragon-slayer-sword-to-cut-vegetables--unnecessary-generic-overuse aria-label="Pitfall #1: Using a Dragon Slayer Sword to Cut Vegetables — Unnecessary Generic Overuse">Pitfall #1: Using a Dragon Slayer Sword to Cut Vegetables — Unnecessary Generic Overuse</a></li><li><a href=#pitfall-2-code-spaghetti--chaotic-trait-constraints aria-label="Pitfall #2: Code &ldquo;Spaghetti&rdquo; — Chaotic Trait Constraints">Pitfall #2: Code &ldquo;Spaghetti&rdquo; — Chaotic Trait Constraints</a></li><li><a href=#pitfall-3-confusing-static-with-dynamic--mixing-generics-with-trait-objects aria-label="Pitfall #3: Confusing &ldquo;Static&rdquo; with &ldquo;Dynamic&rdquo; — Mixing Generics with Trait Objects">Pitfall #3: Confusing &ldquo;Static&rdquo; with &ldquo;Dynamic&rdquo; — Mixing Generics with Trait Objects</a></li><li><a href=#pitfall-4-messing-up-the-trait-family--not-using-associated-types-self-inflicted-trouble aria-label="Pitfall #4: Messing Up the Trait &ldquo;Family&rdquo; — Not Using Associated Types, Self-inflicted Trouble">Pitfall #4: Messing Up the Trait &ldquo;Family&rdquo; — Not Using Associated Types, Self-inflicted Trouble</a></li><li><a href=#pitfall-5-premature-commitment--abusing-constraints-on-structs aria-label="Pitfall #5: Premature &ldquo;Commitment&rdquo; — Abusing Constraints on Structs">Pitfall #5: Premature &ldquo;Commitment&rdquo; — Abusing Constraints on Structs</a></li><li><a href=#conclusion-from-pitfalls-to-highways aria-label="Conclusion: From &ldquo;Pitfalls&rdquo; to &ldquo;Highways&rdquo;">Conclusion: From &ldquo;Pitfalls&rdquo; to &ldquo;Highways&rdquo;</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=rust-ultimate-guide-5-trait--generic-pitfalls-that-will-make-your-colleagues-unreachable>Rust Ultimate Guide: 5 Trait & Generic Pitfalls That Will Make Your Colleagues &lsquo;Unreachable&rsquo;<a hidden class=anchor aria-hidden=true href=#rust-ultimate-guide-5-trait--generic-pitfalls-that-will-make-your-colleagues-unreachable>#</a></h1><p><strong>Follow Dream Beast Programming WeChat Official Account for humorous Rust learning</strong></p><p>Hello, brave Rustacean!</p><p>Have you ever been &ldquo;ground to dust&rdquo; by Rust&rsquo;s compiler? Facing a screen full of cryptic error messages, wondering if you chose the wrong programming language? Don&rsquo;t worry, you&rsquo;re not alone in this battle.</p><p>Rust&rsquo;s most powerful weapon is its &ldquo;zero-cost abstraction&rdquo; capability. The core secret of this martial art is <strong>Traits</strong>, <strong>Generics</strong>, and <strong>Where clauses</strong>. Used correctly, your code will be as elegant as poetry and as fast as an F1 race car.</p><p>But&mldr; what if you use them wrong? They instantly become a pot of &ldquo;spaghetti&rdquo; that makes your scalp tingle, with compilation errors that could circle the Earth three times, enough to scare any programming novice into uninstalling Rust overnight.</p><p>Today I&rsquo;ll reveal and fill in those most common Trait and Generic &ldquo;pitfalls&rdquo;. Buckle up, let&rsquo;s go!</p><h2 id=pitfall-1-using-a-dragon-slayer-sword-to-cut-vegetables--unnecessary-generic-overuse>Pitfall #1: Using a Dragon Slayer Sword to Cut Vegetables — Unnecessary Generic Overuse<a hidden class=anchor aria-hidden=true href=#pitfall-1-using-a-dragon-slayer-sword-to-cut-vegetables--unnecessary-generic-overuse>#</a></h2><p>Imagine you have a sword that can cut through iron like mud, but you use it every day to slice potatoes. Isn&rsquo;t that a bit overkill?</p><p><strong>The mistake you might be making:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Looks fine, right?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_value</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>std</span>::fmt::Debug<span style=color:#f92672>&gt;</span>(value: <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, value);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Technically, this code runs. But the problem is, if throughout your entire project, you&rsquo;re only ever passing an <code>i32</code> type to this function, why are you using generics?</p><p>You&rsquo;re adding unnecessary complexity for flexibility that doesn&rsquo;t exist. The compiler needs to perform &ldquo;monomorphization&rdquo; for each concrete type, generating additional code. It&rsquo;s like renovating all your rooms to five-star presidential suite standards just in case you might occasionally host a king, but the only visitor is always your neighbor Lao Wang.</p><p><strong>The wiser approach:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Simple but efficient
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_value</span>(value: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, value);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>My divine mantra:</strong> Remember, generics are your superpower, but don&rsquo;t show off your muscles too early. Only summon the &ldquo;dragon&rdquo; of generics when you <strong>truly need</strong> to handle multiple types. Otherwise, starting with concrete types is always the most efficient and clearest choice.</p><h2 id=pitfall-2-code-spaghetti--chaotic-trait-constraints>Pitfall #2: Code &ldquo;Spaghetti&rdquo; — Chaotic Trait Constraints<a hidden class=anchor aria-hidden=true href=#pitfall-2-code-spaghetti--chaotic-trait-constraints>#</a></h2><p>When your function needs more than one generic parameter, and each parameter comes with a bunch of constraints, your function signature quickly becomes an incomprehensible bowl of &ldquo;spaghetti&rdquo;.</p><p><strong>The mistake you might be making:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// One parameter is okay, but try two?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>log_json</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>serde</span>::Serialize <span style=color:#f92672>+</span> std::fmt::Debug <span style=color:#f92672>+</span> Clone<span style=color:#f92672>&gt;</span>(item: <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>As constraints multiply, the content inside angle brackets <code>&lt;></code> gets longer and longer, readability plummets, and maintenance becomes a nightmare.</p><p><strong>The wiser approach: Let <code>where</code> clauses save you!</strong></p><p><code>where</code> clauses are like professional librarians who neatly organize all the messy constraint conditions, making your function signatures as refreshing as a summer breeze.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Using where makes the code instantly clean
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>log_json</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(item: <span style=color:#a6e22e>T</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    T: <span style=color:#a6e22e>serde</span>::Serialize <span style=color:#f92672>+</span> std::fmt::Debug <span style=color:#f92672>+</span> Clone,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Multiple parameters? Piece of cake!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process_data</span><span style=color:#f92672>&lt;</span>T, U<span style=color:#f92672>&gt;</span>(a: <span style=color:#a6e22e>T</span>, b: <span style=color:#a6e22e>U</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    T: Clone <span style=color:#f92672>+</span> std::fmt::Debug,
</span></span><span style=display:flex><span>    U: Default <span style=color:#f92672>+</span> std::fmt::Debug,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><strong>My divine mantra:</strong> Liberate constraint conditions from angle brackets and let <code>where</code> clauses manage them. This isn&rsquo;t just a style issue; it&rsquo;s the lifeline of code readability and maintainability.</p><h2 id=pitfall-3-confusing-static-with-dynamic--mixing-generics-with-trait-objects>Pitfall #3: Confusing &ldquo;Static&rdquo; with &ldquo;Dynamic&rdquo; — Mixing Generics with Trait Objects<a hidden class=anchor aria-hidden=true href=#pitfall-3-confusing-static-with-dynamic--mixing-generics-with-trait-objects>#</a></h2><p>This is the pit that newcomers fall into most easily. Generics and trait objects (<code>dyn Trait</code>) can both achieve polymorphism, but their application scenarios are completely different.</p><ul><li><strong>Generics</strong>: <strong>Static dispatch</strong>. At compile time, the compiler knows all concrete types and generates code for each type. Fast, but not flexible enough; you can&rsquo;t store instances of different types in one collection.</li><li><strong>Trait objects (<code>&amp;dyn Trait</code>)</strong>: <strong>Dynamic dispatch</strong>. At runtime, methods are called through virtual function tables (vtables). Slightly slower (almost negligible), but extremely flexible, allowing you to create heterogeneous collections (like a list containing cats, dogs, and birds).</li></ul><p><strong>The mistake you might be making:</strong></p><p>You want to create a function that can accept anything that can &ldquo;draw&rdquo; itself, so you write a generic version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>trait</span> Drawable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw</span>(<span style=color:#f92672>&amp;</span>self);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This function can only accept one specific Drawable type at a time
</span></span></span><span style=display:flex><span><span style=color:#75715e>// You can&#39;t pass it a list containing both Circle and Square
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_static</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>Drawable</span><span style=color:#f92672>&gt;</span>(item: <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>    item.draw();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>The wiser approach: Embrace <code>dyn Trait</code> when you need heterogeneous collections</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Using trait objects, accepts any type that implements Drawable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_dynamic</span>(item: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> Drawable) {
</span></span><span style=display:flex><span>    item.draw();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Ultimate usage: render a scene containing various shapes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>render_scene</span>(items: Vec<span style=color:#f92672>&lt;</span>Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Drawable<span style=color:#f92672>&gt;&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> item <span style=color:#66d9ef>in</span> items {
</span></span><span style=display:flex><span>        item.draw();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>My divine mantra:</strong> Simple rule: When you need a function or struct to determine types at <strong>compile time</strong>, pursuing ultimate performance, use generics. When you need to handle a collection containing multiple different types (but all implementing the same trait) at <strong>runtime</strong>, don&rsquo;t hesitate to use trait objects. This is the correct way to open &ldquo;duck typing&rdquo; in Rust.</p><h2 id=pitfall-4-messing-up-the-trait-family--not-using-associated-types-self-inflicted-trouble>Pitfall #4: Messing Up the Trait &ldquo;Family&rdquo; — Not Using Associated Types, Self-inflicted Trouble<a hidden class=anchor aria-hidden=true href=#pitfall-4-messing-up-the-trait-family--not-using-associated-types-self-inflicted-trouble>#</a></h2><p>When multiple methods within a trait depend on the same &ldquo;auxiliary type&rdquo;, using generics makes things extremely awkward.</p><p><strong>The mistake you might be making:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Using generics to define stored item types, too verbose!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>trait</span> Storage<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>save</span>(<span style=color:#f92672>&amp;</span>self, item: <span style=color:#a6e22e>T</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>T</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This approach becomes very awkward when implementing (<code>impl</code>), because you need to drag that generic <code>T</code> everywhere.</p><p><strong>The wiser approach: Use Associated Types</strong></p><p>Associated types make your traits more &ldquo;cohesive&rdquo; and clear. It&rsquo;s like saying: &ldquo;Any type that implements my <code>Storage</code> trait must <strong>internally specify</strong> an <code>Item</code> type that it stores.&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>trait</span> Storage {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span>; <span style=color:#75715e>// Define associated type here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>save</span>(<span style=color:#f92672>&amp;</span>self, item: <span style=color:#a6e22e>Self</span>::Item);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Self</span>::Item;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Implementation is so clean!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MemoryStorage</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Storage <span style=color:#66d9ef>for</span> MemoryStorage {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> String; <span style=color:#75715e>// Directly specify concrete type here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>save</span>(<span style=color:#f92672>&amp;</span>self, item: String) { <span style=color:#75715e>/* ... */</span> }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(<span style=color:#f92672>&amp;</span>self) -&gt; String { <span style=color:#75715e>/* ... */</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>My divine mantra:</strong> When a type in a trait is strongly related to the type implementing that trait, please use associated types. They can greatly simplify APIs and make your trait design more elegant.</p><h2 id=pitfall-5-premature-commitment--abusing-constraints-on-structs>Pitfall #5: Premature &ldquo;Commitment&rdquo; — Abusing Constraints on Structs<a hidden class=anchor aria-hidden=true href=#pitfall-5-premature-commitment--abusing-constraints-on-structs>#</a></h2><p>This is a very subtle but far-reaching bad habit.</p><p><strong>The mistake you might be making:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Adding Display constraint when defining the struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Wrapper</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>std</span>::fmt::Display<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    value: <span style=color:#a6e22e>T</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here&rsquo;s the problem: This means you <strong>can&rsquo;t even create a <code>Wrapper</code> instance</strong> unless the <code>T</code> type inside it implements the <code>Display</code> trait—even if you don&rsquo;t plan to print it anytime soon! This constraint is too domineering.</p><p><strong>The wiser approach: Only add constraints when needed</strong></p><p>Move constraints from struct definitions to <code>impl</code> blocks or methods that truly need them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// The struct itself has no constraints
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Wrapper</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    value: <span style=color:#a6e22e>T</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Only add Display constraint on the show method that needs printing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>std</span>::fmt::Display<span style=color:#f92672>&gt;</span> Wrapper<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>show</span>(<span style=color:#f92672>&amp;</span>self) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, self.value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>My divine mantra:</strong> Give your structs maximum freedom. Don&rsquo;t &ldquo;lock them down&rdquo; with trait constraints at definition time. Only make your demands in specific method implementations (<code>impl</code>). This is the essence of the &ldquo;principle of least privilege&rdquo;.</p><h2 id=conclusion-from-pitfalls-to-highways>Conclusion: From &ldquo;Pitfalls&rdquo; to &ldquo;Highways&rdquo;<a hidden class=anchor aria-hidden=true href=#conclusion-from-pitfalls-to-highways>#</a></h2><p>Congratulations! You&rsquo;ve successfully navigated around these five most dangerous &ldquo;pitfalls&rdquo;!</p><p>Traits and generics are the dragon-slaying skills that Rust has bestowed upon you. They are powerful and flexible, but they also require wisdom and discipline to master. Remember what you learned today:</p><ul><li><strong>From concrete to abstract</strong>, don&rsquo;t abuse generics.</li><li><strong>Use <code>where</code></strong> to &ldquo;clean&rdquo; your code signatures.</li><li><strong>Distinguish static from dynamic</strong>, make correct choices between generics and <code>dyn Trait</code>.</li><li><strong>Embrace associated types</strong>, design clearer traits.</li><li><strong>Let constraints be &ldquo;just right&rdquo;</strong>, don&rsquo;t prematurely limit your structs.</li></ul><p>Mastering these will elevate your Rust code to a whole new level, and the compiler will become your closest friend, not your enemy.</p><p>Want to unlock more black tech that will boost your skills?</p><p><strong>Follow Dream Beast Programming WeChat Official Account for more black tech</strong>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rexai.top/tags/rust/>Rust</a></li><li><a href=https://rexai.top/tags/traits/>Traits</a></li><li><a href=https://rexai.top/tags/generics/>Generics</a></li><li><a href=https://rexai.top/tags/programming-tutorial/>Programming Tutorial</a></li><li><a href=https://rexai.top/tags/best-practices/>Best Practices</a></li><li><a href=https://rexai.top/tags/performance-optimization/>Performance Optimization</a></li></ul></footer></article></main><footer class=footer><span>© <a href=https://rexai.top/>梦兽编程</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>