<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes | Ê¢¶ÂÖΩÁºñÁ®ã</title><meta name=keywords content="Rust,Async Programming,async/await,Tokio,Performance Tuning,Common Mistakes,Rust Tutorial"><meta name=description content="A deep dive into 7 common Rust async programming pitfalls, such as blocking threads, incorrect lock usage, and mishandled Futures. Learn to avoid these mistakes with practical examples to write high-performance, stable asynchronous code."><meta name=author content="Rexai Programming"><link rel=canonical href=https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/><meta name=msvalidate.01 content="DFC221DBAE81D3FE5D692A4C8F3670CF"><link crossorigin=anonymous href=/assets/css/stylesheet.852d08305fd9657bd0c1817a6ba86d4d8a66d40bbd25a67d45a8f93eb25903a1.css integrity="sha256-hS0IMF/ZZXvQwYF6a6htTYpm1Au9JaZ9Raj5PrJZA6E=" rel="preload stylesheet" as=style><link rel=icon href=https://rexai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rexai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rexai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://rexai.top/apple-touch-icon.png><link rel=mask-icon href=https://rexai.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://rexai.top/zh-cn/tutorials/rust/rust-async-common-mistakes-to-avoid/><link rel=alternate hreflang=en href=https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.promotion-section{margin-top:2rem;text-align:center}.promotion-section h3{margin-bottom:1.5rem;color:var(--primary);font-size:1.25rem}.qr-codes{display:flex;gap:2rem;justify-content:center;flex-wrap:wrap}.qr-item{text-align:center}.qr-item img{width:150px;height:150px;border:1px solid #ddd;border-radius:8px;padding:8px;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.1);transition:transform .2s}.qr-item img:hover{transform:scale(1.05)}.qr-item p{margin-top:.5rem;font-size:.9rem;color:var(--secondary);font-weight:500}@media(max-width:768px){.qr-codes{flex-direction:column;align-items:center;gap:1rem}.qr-item img{width:120px;height:120px}}</style><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-K6VQRF8T")</script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=winbbryz data-description="Support me on Buy me a coffee!" data-message data-color=#FF813F data-position=Right data-x_margin=18 data-y_margin=18></script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K6VQRF8T" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><meta property="og:url" content="https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/"><meta property="og:site_name" content="Ê¢¶ÂÖΩÁºñÁ®ã"><meta property="og:title" content="Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes"><meta property="og:description" content="A deep dive into 7 common Rust async programming pitfalls, such as blocking threads, incorrect lock usage, and mishandled Futures. Learn to avoid these mistakes with practical examples to write high-performance, stable asynchronous code."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2024-07-31T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-31T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Async"><meta property="article:tag" content="Tokio"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Tutorial"><meta property="og:image" content="https://rexai.top/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rexai.top/cover.png"><meta name=twitter:title content="Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes"><meta name=twitter:description content="A deep dive into 7 common Rust async programming pitfalls, such as blocking threads, incorrect lock usage, and mishandled Futures. Learn to avoid these mistakes with practical examples to write high-performance, stable asynchronous code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://rexai.top/tutorials/"},{"@type":"ListItem","position":2,"name":"Rust Tutorials","item":"https://rexai.top/tutorials/rust/"},{"@type":"ListItem","position":3,"name":"Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes","item":"https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes","name":"Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes","description":"A deep dive into 7 common Rust async programming pitfalls, such as blocking threads, incorrect lock usage, and mishandled Futures. Learn to avoid these mistakes with practical examples to write high-performance, stable asynchronous code.","keywords":["Rust","Async Programming","async/await","Tokio","Performance Tuning","Common Mistakes","Rust Tutorial"],"articleBody":"\nFollow Dream-Beast Programming for a fun way to learn Rust\nEver found yourself scratching your head over a pile of Rust async code? You write async/await with high hopes of silky-smooth, high-performance execution, only to be ‚Äúpleasantly surprised‚Äù by a slow and crash-prone application.\nDon‚Äôt worry, you‚Äôre not alone. Rust‚Äôs async world is like a dungeon full of powerful magic and hidden traps. This is especially true for developers coming from languages like JavaScript, Python, or Go. Your old maps are useless here. The patterns you‚Äôre used to can be deadly sins in the eyes of Rust.\nToday, I‚Äôll be your guide, helping you hunt down the ‚Äúassassins‚Äù lurking in your code to bring your async programs back to life and make them great again!\nMistake 1: Awaiting a Future in a Synchronous Function Imagine an async function is a recipe detailing ‚Äúhow‚Äù to cook a dish (e.g., fetch data from a server). The .await is the chef who actually rolls up their sleeves and ‚Äúexecutes‚Äù the cooking.\nThe Deadly Code:\nfn main() { fetch_data().await; // The assassin is here! The compiler will slap you for this. } async fn fetch_data() { println!(\"I'm trying to fetch data...\"); } How It Kills: You can‚Äôt just ask the chef (.await) to start working inside a regular synchronous function (like main). That‚Äôs like shouting ‚ÄúStart cooking!‚Äù from your bedroom; the stove in the kitchen won‚Äôt hear you. Rust is principled: The chef (.await) can only work in the kitchen (an async block or function).\nThe Counter-Strategy: Give the Chef a Kitchen You need an async ‚Äúruntime,‚Äù like the famous tokio or async-std. It creates an entry point for your asynchronous world‚Äîa real ‚Äúkitchen.‚Äù\n#[tokio::main] // This is like putting a chef's hat on the main function async fn main() { fetch_data().await; // Now this makes sense! } async fn fetch_data() { println!(\"Fetching data...\"); } Remember, the #[tokio::main] macro is the key to unlocking the async world.\nMistake 2: Blocking the Async Thread with std::thread::sleep In the async world, the executor is like a hyperactive courier, constantly juggling hundreds or thousands of packages (tasks) at once.\nThe Deadly Code:\nuse std::thread::sleep; use std::time::Duration; async fn process() { println!(\"Starting process...\"); // The assassin appears! You're making the hyperactive courier stand still for 5 seconds. sleep(Duration::from_secs(5)); println!(\"Process finished\"); } How It Kills: When you use std::thread::sleep, you‚Äôre not just pausing the current ‚Äútask.‚Äù You‚Äôre shouting at the entire courier system: ‚ÄúEveryone, halt for 5 seconds!‚Äù The courier (the runtime thread) literally stops, and all other packages (tasks) are left waiting. This is called ‚Äúblocking the thread.‚Äù\nThe Counter-Strategy: Use an Async ‚ÄúSmart Alarm‚Äù You need to use the async version of sleep provided by your runtime. It‚Äôs like a smart alarm. You tell the courier, ‚ÄúHandle this package in 5 seconds.‚Äù The courier sets it aside and continues delivering other urgent packages. After 5 seconds, the alarm goes off, and the courier comes back to it.\nuse tokio::time::{sleep, Duration}; // Note the import source! async fn process() { println!(\"Starting process...\"); // This is the correct way to sleep in async. sleep(Duration::from_secs(5)).await; println!(\"Process finished\"); } Core principle: In async code, use async tools. Stay away from std::thread and embrace tokio:: or async_std::.\nMistake 3: Mixing Incompatible Runtimes Tokio and async-std are both excellent async runtimes, but they are like two powerful, incompatible CEOs.\nThe Deadly Code (in cargo.toml):\n[dependencies] tokio = { version = \"1\", features = [\"full\"] } async-std = \"1.10\" # The assassin is watching from the shadows How It Kills: Inviting both into your project is like appointing two competing heirs to the throne. They will fight over resources (thread pools, task scheduling), leading to bizarre runtime errors, task conflicts, and even outright crashes.\nThe Counter-Strategy: Be Loyal! Pick One Unless you absolutely know what you‚Äôre doing (e.g., writing a library that needs to be compatible with both), please make a choice and stick to it. If you use Tokio, use the Tokio ecosystem from top to bottom. The same goes for async-std.\nMistake 4: Forgetting the JoinHandle Ghost tokio::spawn is like creating a clone of yourself to handle a sub-task. It‚Äôs very cool, but if you don‚Äôt manage this clone, it might turn into a ghost.\nThe Deadly Code:\nasync fn main_task() { tokio::spawn(do_work()); // Launched, and then what? println!(\"Main task finished\"); } async fn do_work() { // I might need some time to finish... println!(\"Working hard...\"); } How It Kills: You launched a sub-task with spawn, but the main task main_task doesn‚Äôt care if it‚Äôs finished and just ends. This can cause the entire program to exit before do_work even has a chance to run, or while it‚Äôs halfway through. Your spawned task becomes a kite with a snapped string, its fate unknown.\nThe Counter-Strategy: Acknowledge It, Wait for It spawn returns something called a JoinHandle, which is like a ‚Äúcontroller‚Äù for the clone you sent out. You must .await this controller to tell the main task: ‚ÄúHey, hold on, wait for my clone to finish its work before we proceed.‚Äù\nasync fn main_task() { let handle = tokio::spawn(do_work()); // Wait for the sub-task to complete handle.await.unwrap(); println!(\"Main task is done, after confirming the clone is also done.\"); } If you have multiple sub-tasks, you can use tokio::join! to elegantly wait for all of them to complete.\nMistake 5: The Deadly Temptation of .unwrap() .unwrap() is a favorite for Rust newcomers and a nightmare for production code. It translates to: ‚ÄúI‚Äôm certain there‚Äôs a value here. If not, just let the program crash!‚Äù\nThe Deadly Code:\nasync fn main_task() { // Deadly code. If the URL is invalid or the network is down, the whole program panics. let res = reqwest::get(\"http://a-non-existent-url.com\").await.unwrap(); } How It Kills: The async world is full of uncertainty: networks can be flaky, servers can go down, files might not exist. Chaining an .unwrap() after any of these fallible operations is like running naked through a minefield. A small network hiccup is enough to bring your entire service down.\nThe Counter-Strategy: Gracefully Handle Every Possibility Please, like a mature engineer, use match or the ? operator to handle Result.\nasync fn main_task() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { match reqwest::get(\"http://a-non-existent-url.com\").await { Ok(res) =\u003e println!(\"Success! Response: {:?}\", res), Err(e) =\u003e eprintln!(\"An error occurred, but the program is still alive: {}\", e), } Ok(()) } Remember, in async code, errors are normal. Handle them gracefully, and your program will be rock-solid.\n(Note: Mistakes 6 and 7 are variations of 2 and 5, but are more subtle and just as deadly!)\nMistake 6: Using the Wrong Lock and Locking the Universe When you need to share data between multiple async tasks, you need a lock. But if you use the wrong one, the consequences can be just as devastating.\nThe Deadly Code:\nuse std::sync::Mutex; // Assassin: This is a lock from the synchronous world! use std::sync::Arc; let data = Arc::new(Mutex::new(0)); // Inside some async fn let mut d = data.lock().unwrap(); // If this lock is held, other tasks are stuck waiting How It Kills: std::sync::Mutex is a blocking lock. When an async task acquires this lock but then gets suspended (e.g., due to an .await), it does not release the lock! It holds onto it, forcing any other task that needs the lock to wait, effectively blocking the system again.\nThe Counter-Strategy: Use the Async ‚ÄúSmart Lock‚Äù You must use the Mutex provided by your async runtime.\nuse tokio::sync::Mutex; // Note the source! This is the async-safe lock. use std::sync::Arc; let data = Arc::new(Mutex::new(0)); // Inside some async fn let mut d = data.lock().await; // Note, this now uses .await! The .lock() operation on tokio::sync::Mutex is itself an async operation. When a task holding the lock needs to .await something else, the runtime is smart enough to yield CPU time to other tasks instead of selfishly holding onto the resource.\nMistake 7: The Ignored .await This is the most subtle and often most frustrating assassin. You‚Äôve written the async code, but you forgot the most important part: .await.\nThe Deadly Code:\nuse std::time::Duration; async fn run() { // This creates a \"future\" plan to sleep for 3 seconds, but doesn't execute it. tokio::time::sleep(Duration::from_secs(3)); println!(\"Did I finish sleeping? No, I never even started!\"); } How It Kills: Calling an async function (like tokio::time::sleep) doesn‚Äôt execute it immediately. It only returns a Future object, which is merely a ‚Äúplan.‚Äù You must use .await to tell the runtime, ‚ÄúHey, execute this plan!‚Äù If you forget .await, the plan is simply dropped, and nothing happens. The program will instantly print the message, leaving you completely baffled.\nThe Counter-Strategy: Always Be Vigilant For any function call that returns a Future, ask yourself: ‚ÄúDid I forget to .await?‚Äù Luckily, the compiler will often warn you about this, but developing this vigilance yourself is crucial.\nSummary: Becoming an Async Master Alright, all seven ‚Äúassassins‚Äù have been exposed. Let‚Äôs put them on a most-wanted poster:\nAssassin‚Äôs Codename Crime Description The Silver Bullet (Solution) The Orphan Future Using .await in a sync function Use #[tokio::main] or similar to create an async entry point The Fatal Block Using std::thread::sleep Switch to tokio::time::sleep The Runtime Riot Mixing Tokio and async-std Stay loyal to one runtime The Forgotten Ghost Spawning a task but not .awaiting its JoinHandle Wait for the handle.await The Deadly Temptation Using .unwrap() on async operations Use match or ? for error handling The Universe Lock Using std::sync::Mutex in async code Switch to tokio::sync::Mutex The Ignored .await Calling an async function without .awaiting it Always check for and add the missing .await Mastering Rust‚Äôs asynchronous programming is all about learning to ‚Äúthink asynchronously.‚Äù Forget the habits from the synchronous world and embrace the model of Futures and runtime schedulers. When you can naturally dodge these ‚Äúassassins,‚Äù you‚Äôre well on your way to becoming an async master.\n","wordCount":"1634","inLanguage":"en","image":"https://rexai.top/cover.png","datePublished":"2024-07-31T00:00:00Z","dateModified":"2024-07-31T00:00:00Z","author":{"@type":"Person","name":"Rexai Programming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/"},"publisher":{"@type":"Organization","name":"Ê¢¶ÂÖΩÁºñÁ®ã","logo":{"@type":"ImageObject","url":"https://rexai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rexai.top/ accesskey=h title="Ê¢¶ÂÖΩÁºñÁ®ã (Alt + H)">Ê¢¶ÂÖΩÁºñÁ®ã</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://rexai.top/zh-cn/ title=‰∏≠Êñá aria-label=‰∏≠Êñá>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://rexai.top/ title=Home><span>Home</span></a></li><li class=has-submenu><a href=https://rexai.top/tutorials/ title="üìö Tutorials"><span>üìö Tutorials</span>
<span class=submenu-toggle>‚ñº</span></a><ul class=submenu><li><a href=https://rexai.top/tutorials/rust/ title=Rust>Rust</a></li><li><a href=https://rexai.top/tutorials/ai/ title="AI Programming">AI Programming</a></li></ul></li><li><a href=https://rexai.top/tools/ title=Tools><span>Tools</span></a></li><li><a href=https://rexai.top/news/ title="üî• News"><span>üî• News</span></a></li><li><a href=https://rexai.top/tags/ title="üè∑Ô∏è Tags"><span>üè∑Ô∏è Tags</span></a></li><li><a href=https://rexai.top/categories/ title="üìÇ Categories"><span>üìÇ Categories</span></a></li></ul></nav></header><style>.has-submenu{position:relative}#menu{overflow:visible !important}#menu li{overflow:visible}.submenu{position:absolute;top:100%;left:0;background:var(--theme);border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);min-width:180px;z-index:1000;list-style:none;display:none;padding:.5rem 0}.submenu li{display:block;margin:0;line-height:1.5}#menu .submenu li+li{margin-inline-start:0}.submenu a{display:block;padding:.75rem 1rem;color:var(--secondary);text-decoration:none;transition:all .2s ease;border-radius:0}.submenu a:hover{background:var(--entry);color:var(--primary)}.has-submenu:hover .submenu{display:block !important}.submenu-toggle{margin-left:.25rem;font-size:.75rem;transition:transform .2s ease;display:inline-block}.has-submenu:hover .submenu-toggle{transform:rotate(180deg)}@media(max-width:768px){.submenu{position:static;box-shadow:none;border:none;background:var(--entry);margin-top:0;margin-left:1rem;display:none;padding:0}.has-submenu.active .submenu{display:block}.submenu-toggle{cursor:pointer}}</style><script>window.innerWidth<=768&&document.querySelectorAll(".has-submenu").forEach(e=>{const n=e.querySelector("a"),t=e.querySelector(".submenu-toggle");t&&(t.addEventListener("click",function(t){t.preventDefault(),e.classList.toggle("active")}),n.addEventListener("click",function(t){e.classList.contains("has-submenu")&&(t.preventDefault(),e.classList.toggle("active"))}))})</script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes</h1><div class=post-description>A deep dive into 7 common Rust async programming pitfalls, such as blocking threads, incorrect lock usage, and mishandled Futures. Learn to avoid these mistakes with practical examples to write high-performance, stable asynchronous code.</div><div class=post-meta><span title='2024-07-31 00:00:00 +0000 UTC'>July 31, 2024</span>&nbsp;¬∑&nbsp;8 min&nbsp;¬∑&nbsp;1634 words&nbsp;¬∑&nbsp;Rexai Programming&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://rexai.top/zh-cn/tutorials/rust/rust-async-common-mistakes-to-avoid/>Zh-Cn</a></li></ul></div></header><figure class=entry-cover><img loading=eager srcset='https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/cover_hu_675ecc127145bdf0.png 360w,https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/cover_hu_e5515573683c9d40.png 480w,https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/cover_hu_39d989e626b497e8.png 720w,https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/cover.png 800w' src=https://rexai.top/tutorials/rust/rust-async-common-mistakes-to-avoid/cover.png sizes="(min-width: 768px) 720px, 100vw" width=800 height=533 alt="Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes"><figcaption>Illustration of common pitfalls in Rust asynchronous programming</figcaption></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#mistake-1-awaiting-a-future-in-a-synchronous-function aria-label="Mistake 1: Awaiting a Future in a Synchronous Function">Mistake 1: Awaiting a Future in a Synchronous Function</a></li><li><a href=#mistake-2-blocking-the-async-thread-with-stdthreadsleep aria-label="Mistake 2: Blocking the Async Thread with std::thread::sleep">Mistake 2: Blocking the Async Thread with std::thread::sleep</a></li><li><a href=#mistake-3-mixing-incompatible-runtimes aria-label="Mistake 3: Mixing Incompatible Runtimes">Mistake 3: Mixing Incompatible Runtimes</a></li><li><a href=#mistake-4-forgetting-the-joinhandle-ghost aria-label="Mistake 4: Forgetting the JoinHandle Ghost">Mistake 4: Forgetting the JoinHandle Ghost</a></li><li><a href=#mistake-5-the-deadly-temptation-of-unwrap aria-label="Mistake 5: The Deadly Temptation of .unwrap()">Mistake 5: The Deadly Temptation of .unwrap()</a></li><li><a href=#mistake-6-using-the-wrong-lock-and-locking-the-universe aria-label="Mistake 6: Using the Wrong Lock and Locking the Universe">Mistake 6: Using the Wrong Lock and Locking the Universe</a></li><li><a href=#mistake-7-the-ignored-await aria-label="Mistake 7: The Ignored .await">Mistake 7: The Ignored .await</a><ul><li><a href=#summary-becoming-an-async-master aria-label="Summary: Becoming an Async Master">Summary: Becoming an Async Master</a></li></ul></li></ul></div></details></div><div class=post-content><p><img alt="Rust Async: 7 Common Mistakes That Kill Performance and Cause Crashes" loading=lazy src=/tutorials/rust/rust-async-common-mistakes-to-avoid/cover.png></p><p><strong>Follow Dream-Beast Programming for a fun way to learn Rust</strong></p><p>Ever found yourself scratching your head over a pile of Rust async code? You write <code>async/await</code> with high hopes of silky-smooth, high-performance execution, only to be &ldquo;pleasantly surprised&rdquo; by a slow and crash-prone application.</p><p>Don&rsquo;t worry, you&rsquo;re not alone. Rust&rsquo;s async world is like a dungeon full of powerful magic and hidden traps. This is especially true for developers coming from languages like JavaScript, Python, or Go. Your old maps are useless here. The patterns you&rsquo;re used to can be deadly sins in the eyes of Rust.</p><p>Today, I&rsquo;ll be your guide, helping you hunt down the &ldquo;assassins&rdquo; lurking in your code to bring your async programs back to life and make them great again!</p><h2 id=mistake-1-awaiting-a-future-in-a-synchronous-function>Mistake 1: Awaiting a Future in a Synchronous Function<a hidden class=anchor aria-hidden=true href=#mistake-1-awaiting-a-future-in-a-synchronous-function>#</a></h2><p>Imagine an <code>async</code> function is a recipe detailing &ldquo;how&rdquo; to cook a dish (e.g., fetch data from a server). The <code>.await</code> is the chef who actually rolls up their sleeves and &ldquo;executes&rdquo; the cooking.</p><p><strong>The Deadly Code:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    fetch_data().<span style=color:#66d9ef>await</span>; <span style=color:#75715e>// The assassin is here! The compiler will slap you for this.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fetch_data</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;I&#39;m trying to fetch data...&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>How It Kills:</strong>
You can&rsquo;t just ask the chef (<code>.await</code>) to start working inside a regular synchronous function (like <code>main</code>). That&rsquo;s like shouting &ldquo;Start cooking!&rdquo; from your bedroom; the stove in the kitchen won&rsquo;t hear you. Rust is principled: <strong>The chef (<code>.await</code>) can only work in the kitchen (an <code>async</code> block or function).</strong></p><p><strong>The Counter-Strategy: Give the Chef a Kitchen</strong>
You need an async &ldquo;runtime,&rdquo; like the famous <code>tokio</code> or <code>async-std</code>. It creates an entry point for your asynchronous world‚Äîa real &ldquo;kitchen.&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span> <span style=color:#75715e>// This is like putting a chef&#39;s hat on the main function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    fetch_data().<span style=color:#66d9ef>await</span>; <span style=color:#75715e>// Now this makes sense!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fetch_data</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Fetching data...&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Remember, the <code>#[tokio::main]</code> macro is the key to unlocking the async world.</p><h2 id=mistake-2-blocking-the-async-thread-with-stdthreadsleep>Mistake 2: Blocking the Async Thread with <code>std::thread::sleep</code><a hidden class=anchor aria-hidden=true href=#mistake-2-blocking-the-async-thread-with-stdthreadsleep>#</a></h2><p>In the async world, the executor is like a hyperactive courier, constantly juggling hundreds or thousands of packages (tasks) at once.</p><p><strong>The Deadly Code:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread::sleep;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Starting process...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The assassin appears! You&#39;re making the hyperactive courier stand still for 5 seconds.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sleep(Duration::from_secs(<span style=color:#ae81ff>5</span>)); 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Process finished&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>How It Kills:</strong>
When you use <code>std::thread::sleep</code>, you&rsquo;re not just pausing the current &ldquo;task.&rdquo; You&rsquo;re shouting at the entire courier system: &ldquo;Everyone, halt for 5 seconds!&rdquo; The courier (the runtime thread) literally stops, and all other packages (tasks) are left waiting. This is called &ldquo;blocking the thread.&rdquo;</p><p><strong>The Counter-Strategy: Use an Async &ldquo;Smart Alarm&rdquo;</strong>
You need to use the async version of <code>sleep</code> provided by your runtime. It&rsquo;s like a smart alarm. You tell the courier, &ldquo;Handle this package in 5 seconds.&rdquo; The courier sets it aside and continues delivering other urgent packages. After 5 seconds, the alarm goes off, and the courier comes back to it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::time::{sleep, Duration}; <span style=color:#75715e>// Note the import source!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Starting process...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This is the correct way to sleep in async.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sleep(Duration::from_secs(<span style=color:#ae81ff>5</span>)).<span style=color:#66d9ef>await</span>; 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Process finished&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Core principle: In async code, use async tools. Stay away from <code>std::thread</code> and embrace <code>tokio::</code> or <code>async_std::</code>.</strong></p><h2 id=mistake-3-mixing-incompatible-runtimes>Mistake 3: Mixing Incompatible Runtimes<a hidden class=anchor aria-hidden=true href=#mistake-3-mixing-incompatible-runtimes>#</a></h2><p>Tokio and async-std are both excellent async runtimes, but they are like two powerful, incompatible CEOs.</p><p><strong>The Deadly Code (in <code>cargo.toml</code>):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>dependencies</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>tokio</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;1&#34;</span>, <span style=color:#a6e22e>features</span> = [<span style=color:#e6db74>&#34;full&#34;</span>] }
</span></span><span style=display:flex><span><span style=color:#a6e22e>async-std</span> = <span style=color:#e6db74>&#34;1.10&#34;</span> <span style=color:#75715e># The assassin is watching from the shadows</span>
</span></span></code></pre></div><p><strong>How It Kills:</strong>
Inviting both into your project is like appointing two competing heirs to the throne. They will fight over resources (thread pools, task scheduling), leading to bizarre runtime errors, task conflicts, and even outright crashes.</p><p><strong>The Counter-Strategy: Be Loyal! Pick One</strong>
Unless you absolutely know what you&rsquo;re doing (e.g., writing a library that needs to be compatible with both), please make a choice and stick to it. If you use Tokio, use the Tokio ecosystem from top to bottom. The same goes for async-std.</p><h2 id=mistake-4-forgetting-the-joinhandle-ghost>Mistake 4: Forgetting the <code>JoinHandle</code> Ghost<a hidden class=anchor aria-hidden=true href=#mistake-4-forgetting-the-joinhandle-ghost>#</a></h2><p><code>tokio::spawn</code> is like creating a clone of yourself to handle a sub-task. It&rsquo;s very cool, but if you don&rsquo;t manage this clone, it might turn into a ghost.</p><p><strong>The Deadly Code:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main_task</span>() {
</span></span><span style=display:flex><span>    tokio::spawn(do_work()); <span style=color:#75715e>// Launched, and then what?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Main task finished&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>do_work</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// I might need some time to finish...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Working hard...&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>How It Kills:</strong>
You launched a sub-task with <code>spawn</code>, but the main task <code>main_task</code> doesn&rsquo;t care if it&rsquo;s finished and just ends. This can cause the entire program to exit before <code>do_work</code> even has a chance to run, or while it&rsquo;s halfway through. Your spawned task becomes a kite with a snapped string, its fate unknown.</p><p><strong>The Counter-Strategy: Acknowledge It, Wait for It</strong>
<code>spawn</code> returns something called a <code>JoinHandle</code>, which is like a &ldquo;controller&rdquo; for the clone you sent out. You must <code>.await</code> this controller to tell the main task: &ldquo;Hey, hold on, wait for my clone to finish its work before we proceed.&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main_task</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> tokio::spawn(do_work());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wait for the sub-task to complete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    handle.<span style=color:#66d9ef>await</span>.unwrap(); 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Main task is done, after confirming the clone is also done.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you have multiple sub-tasks, you can use <code>tokio::join!</code> to elegantly wait for all of them to complete.</p><h2 id=mistake-5-the-deadly-temptation-of-unwrap>Mistake 5: The Deadly Temptation of <code>.unwrap()</code><a hidden class=anchor aria-hidden=true href=#mistake-5-the-deadly-temptation-of-unwrap>#</a></h2><p><code>.unwrap()</code> is a favorite for Rust newcomers and a nightmare for production code. It translates to: &ldquo;I&rsquo;m certain there&rsquo;s a value here. If not, just let the program crash!&rdquo;</p><p><strong>The Deadly Code:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main_task</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Deadly code. If the URL is invalid or the network is down, the whole program panics.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> res <span style=color:#f92672>=</span> reqwest::get(<span style=color:#e6db74>&#34;http://a-non-existent-url.com&#34;</span>).<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>How It Kills:</strong>
The async world is full of uncertainty: networks can be flaky, servers can go down, files might not exist. Chaining an <code>.unwrap()</code> after any of these fallible operations is like running naked through a minefield. A small network hiccup is enough to bring your entire service down.</p><p><strong>The Counter-Strategy: Gracefully Handle Every Possibility</strong>
Please, like a mature engineer, use <code>match</code> or the <code>?</code> operator to handle <code>Result</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main_task</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> std::error::Error<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> reqwest::get(<span style=color:#e6db74>&#34;http://a-non-existent-url.com&#34;</span>).<span style=color:#66d9ef>await</span> {
</span></span><span style=display:flex><span>        Ok(res) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Success! Response: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, res),
</span></span><span style=display:flex><span>        Err(e) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;An error occurred, but the program is still alive: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, e),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Remember, in async code, errors are normal. Handle them gracefully, and your program will be rock-solid.</p><p><em>(Note: Mistakes 6 and 7 are variations of 2 and 5, but are more subtle and just as deadly!)</em></p><h2 id=mistake-6-using-the-wrong-lock-and-locking-the-universe>Mistake 6: Using the Wrong Lock and Locking the Universe<a hidden class=anchor aria-hidden=true href=#mistake-6-using-the-wrong-lock-and-locking-the-universe>#</a></h2><p>When you need to share data between multiple async tasks, you need a lock. But if you use the wrong one, the consequences can be just as devastating.</p><p><strong>The Deadly Code:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::Mutex; <span style=color:#75715e>// Assassin: This is a lock from the synchronous world!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>use</span> std::sync::Arc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> data <span style=color:#f92672>=</span> Arc::new(Mutex::new(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span><span style=color:#75715e>// Inside some async fn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> d <span style=color:#f92672>=</span> data.lock().unwrap(); <span style=color:#75715e>// If this lock is held, other tasks are stuck waiting
</span></span></span></code></pre></div><p><strong>How It Kills:</strong>
<code>std::sync::Mutex</code> is a <strong>blocking lock</strong>. When an async task acquires this lock but then gets suspended (e.g., due to an <code>.await</code>), it does <strong>not</strong> release the lock! It holds onto it, forcing any other task that needs the lock to wait, effectively blocking the system again.</p><p><strong>The Counter-Strategy: Use the Async &ldquo;Smart Lock&rdquo;</strong>
You must use the <code>Mutex</code> provided by your async runtime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::sync::Mutex; <span style=color:#75715e>// Note the source! This is the async-safe lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>use</span> std::sync::Arc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> data <span style=color:#f92672>=</span> Arc::new(Mutex::new(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span><span style=color:#75715e>// Inside some async fn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> d <span style=color:#f92672>=</span> data.lock().<span style=color:#66d9ef>await</span>; <span style=color:#75715e>// Note, this now uses .await!
</span></span></span></code></pre></div><p>The <code>.lock()</code> operation on <code>tokio::sync::Mutex</code> is itself an async operation. When a task holding the lock needs to <code>.await</code> something else, the runtime is smart enough to yield CPU time to other tasks instead of selfishly holding onto the resource.</p><h2 id=mistake-7-the-ignored-await>Mistake 7: The Ignored <code>.await</code><a hidden class=anchor aria-hidden=true href=#mistake-7-the-ignored-await>#</a></h2><p>This is the most subtle and often most frustrating assassin. You&rsquo;ve written the async code, but you forgot the most important part: <code>.await</code>.</p><p><strong>The Deadly Code:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This creates a &#34;future&#34; plan to sleep for 3 seconds, but doesn&#39;t execute it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    tokio::time::sleep(Duration::from_secs(<span style=color:#ae81ff>3</span>)); 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Did I finish sleeping? No, I never even started!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>How It Kills:</strong>
Calling an <code>async</code> function (like <code>tokio::time::sleep</code>) doesn&rsquo;t execute it immediately. It only returns a <code>Future</code> object, which is merely a &ldquo;plan.&rdquo; You must use <code>.await</code> to tell the runtime, &ldquo;Hey, execute this plan!&rdquo; If you forget <code>.await</code>, the plan is simply dropped, and nothing happens. The program will instantly print the message, leaving you completely baffled.</p><p><strong>The Counter-Strategy: Always Be Vigilant</strong>
For any function call that returns a <code>Future</code>, ask yourself: &ldquo;Did I forget to <code>.await</code>?&rdquo; Luckily, the compiler will often warn you about this, but developing this vigilance yourself is crucial.</p><h3 id=summary-becoming-an-async-master><strong>Summary: Becoming an Async Master</strong><a hidden class=anchor aria-hidden=true href=#summary-becoming-an-async-master>#</a></h3><p>Alright, all seven &ldquo;assassins&rdquo; have been exposed. Let&rsquo;s put them on a most-wanted poster:</p><table><thead><tr><th style=text-align:left>Assassin&rsquo;s Codename</th><th style=text-align:left>Crime Description</th><th style=text-align:left>The Silver Bullet (Solution)</th></tr></thead><tbody><tr><td style=text-align:left><strong>The Orphan Future</strong></td><td style=text-align:left>Using <code>.await</code> in a sync function</td><td style=text-align:left>Use <code>#[tokio::main]</code> or similar to create an async entry point</td></tr><tr><td style=text-align:left><strong>The Fatal Block</strong></td><td style=text-align:left>Using <code>std::thread::sleep</code></td><td style=text-align:left>Switch to <code>tokio::time::sleep</code></td></tr><tr><td style=text-align:left><strong>The Runtime Riot</strong></td><td style=text-align:left>Mixing Tokio and async-std</td><td style=text-align:left>Stay loyal to one runtime</td></tr><tr><td style=text-align:left><strong>The Forgotten Ghost</strong></td><td style=text-align:left>Spawning a task but not <code>.await</code>ing its <code>JoinHandle</code></td><td style=text-align:left>Wait for the <code>handle.await</code></td></tr><tr><td style=text-align:left><strong>The Deadly Temptation</strong></td><td style=text-align:left>Using <code>.unwrap()</code> on async operations</td><td style=text-align:left>Use <code>match</code> or <code>?</code> for error handling</td></tr><tr><td style=text-align:left><strong>The Universe Lock</strong></td><td style=text-align:left>Using <code>std::sync::Mutex</code> in async code</td><td style=text-align:left>Switch to <code>tokio::sync::Mutex</code></td></tr><tr><td style=text-align:left><strong>The Ignored <code>.await</code></strong></td><td style=text-align:left>Calling an async function without <code>.await</code>ing it</td><td style=text-align:left>Always check for and add the missing <code>.await</code></td></tr></tbody></table><p>Mastering Rust&rsquo;s asynchronous programming is all about learning to &ldquo;think asynchronously.&rdquo; Forget the habits from the synchronous world and embrace the model of <code>Future</code>s and runtime schedulers. When you can naturally dodge these &ldquo;assassins,&rdquo; you&rsquo;re well on your way to becoming an async master.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rexai.top/tags/rust/>Rust</a></li><li><a href=https://rexai.top/tags/async/>Async</a></li><li><a href=https://rexai.top/tags/tokio/>Tokio</a></li><li><a href=https://rexai.top/tags/performance/>Performance</a></li><li><a href=https://rexai.top/tags/tutorial/>Tutorial</a></li></ul></footer></article></main><footer class=footer><span>¬© <a href=https://rexai.top/>Ê¢¶ÂÖΩÁºñÁ®ã</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>