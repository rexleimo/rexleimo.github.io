<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Complete Guide to Rust Smart Pointers: Master Box, Rc, and RefCell for Memory Management | 梦兽编程</title><meta name=keywords content="Rust,Smart Pointers,Box,Rc,RefCell,Memory Management,Ownership,Borrowing,Rust Tutorial,Programming"><meta name=description content="Learn Rust smart pointers through vivid analogies and practical examples. Master Box, Rc, and RefCell to understand Rust's memory management system effortlessly"><meta name=author content="Dream Beast Programming"><link rel=canonical href=https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/><meta name=msvalidate.01 content="DFC221DBAE81D3FE5D692A4C8F3670CF"><link crossorigin=anonymous href=/assets/css/stylesheet.852d08305fd9657bd0c1817a6ba86d4d8a66d40bbd25a67d45a8f93eb25903a1.css integrity="sha256-hS0IMF/ZZXvQwYF6a6htTYpm1Au9JaZ9Raj5PrJZA6E=" rel="preload stylesheet" as=style><link rel=icon href=https://rexai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rexai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rexai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://rexai.top/apple-touch-icon.png><link rel=mask-icon href=https://rexai.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://rexai.top/zh-cn/tutorials/rust/rust-smart-pointers-explained-fun-way/><link rel=alternate hreflang=en href=https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.promotion-section{margin-top:2rem;text-align:center}.promotion-section h3{margin-bottom:1.5rem;color:var(--primary);font-size:1.25rem}.qr-codes{display:flex;gap:2rem;justify-content:center;flex-wrap:wrap}.qr-item{text-align:center}.qr-item img{width:150px;height:150px;border:1px solid #ddd;border-radius:8px;padding:8px;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.1);transition:transform .2s}.qr-item img:hover{transform:scale(1.05)}.qr-item p{margin-top:.5rem;font-size:.9rem;color:var(--secondary);font-weight:500}@media(max-width:768px){.qr-codes{flex-direction:column;align-items:center;gap:1rem}.qr-item img{width:120px;height:120px}}</style><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-K6VQRF8T")</script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=winbbryz data-description="Support me on Buy me a coffee!" data-message data-color=#FF813F data-position=Right data-x_margin=18 data-y_margin=18></script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K6VQRF8T" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><meta property="og:url" content="https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/"><meta property="og:site_name" content="梦兽编程"><meta property="og:title" content="Complete Guide to Rust Smart Pointers: Master Box, Rc, and RefCell for Memory Management"><meta property="og:description" content="Learn Rust smart pointers through vivid analogies and practical examples. Master Box, Rc, and RefCell to understand Rust's memory management system effortlessly"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2024-01-15T10:00:00+08:00"><meta property="article:modified_time" content="2024-01-15T10:00:00+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Smart Pointers"><meta property="article:tag" content="Memory Management"><meta property="article:tag" content="Programming Tutorial"><meta property="article:tag" content="Systems Programming"><meta property="og:image" content="https://rexai.top/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rexai.top/cover.png"><meta name=twitter:title content="Complete Guide to Rust Smart Pointers: Master Box, Rc, and RefCell for Memory Management"><meta name=twitter:description content="Learn Rust smart pointers through vivid analogies and practical examples. Master Box, Rc, and RefCell to understand Rust's memory management system effortlessly"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://rexai.top/tutorials/"},{"@type":"ListItem","position":2,"name":"Rust Tutorials","item":"https://rexai.top/tutorials/rust/"},{"@type":"ListItem","position":3,"name":"Complete Guide to Rust Smart Pointers: Master Box, Rc, and RefCell for Memory Management","item":"https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Complete Guide to Rust Smart Pointers: Master Box, Rc, and RefCell for Memory Management","name":"Complete Guide to Rust Smart Pointers: Master Box, Rc, and RefCell for Memory Management","description":"Learn Rust smart pointers through vivid analogies and practical examples. Master Box, Rc, and RefCell to understand Rust's memory management system effortlessly","keywords":["Rust","Smart Pointers","Box","Rc","RefCell","Memory Management","Ownership","Borrowing","Rust Tutorial","Programming"],"articleBody":"Rust Ownership: Stop Memorizing! Play with Smart Pointers as “Toys” - The Big Three (Box, Rc, RefCell) Will Make Memory Management Crystal Clear Hey there, friend! Still getting dizzy with Rust’s ownership system? All that borrowing and lifetime stuff feeling like studying an incomprehensible legal code?\nDon’t worry! Today we’re not going to talk about those big theories. Let’s imagine the code world as a playground, data as beloved toys, and see how Rust makes memory management both safe and fun through several “smart” “toy boxes” (smart pointers).\nToy Box #1: Box — “This toy is too big, it won’t fit in my house!” Imagine you bought an awesome LEGO Millennium Falcon, but it’s too big for your small room (Stack) to hold. What do you do?\nYour mom (the compiler) says: “Silly child, if it doesn’t fit, just rent an external storage locker (Heap)!”\nBox is that “universal box” that helps you rent a storage locker and put your toy inside.\nIt’s simple, it does one thing: moves your data from the stack to the heap. And what do you hold? Just a “key” (pointer) pointing to the storage locker. This “key” itself is small, so your room (stack) can definitely hold it.\n// Can't fit 1 million integers in the room (stack) // let a = [0; 1000000]; // This might crash the program // Use Box to put it in the external storage locker (heap) let b = Box::new([0; 1000000]); // Easy peasy! Most importantly, this storage locker key can only have one owner at a time. If you give the key to your friend, you can’t use it anymore. This is Box’s single ownership. When “you” (the variable holding the Box) leave the playground (scope), Rust automatically helps you return the storage locker, and the toys inside are destroyed, clean and tidy, never forgetful.\nWhen to use it?\nWhen your “toy” is too big and won’t fit on the stack. When you need a “toy list” but each toy in the list has a different size (trait objects Box). When you create a recursive toy that “gives birth to itself” (like a linked list). Toy Box #2: Rc — “My toy, everyone can look at it together!” Now, you have a limited edition comic book (a piece of data), and several of your friends (different parts of the code) want to read it.\nIf you use Box, you give the comic book (ownership) to friend A, and friends B and C can’t read it. This obviously won’t work - the ship of friendship will capsize.\nSo, Rc (Reference Counting) makes its grand entrance! It’s like a “librarian”.\nRc puts your comic book in a public reading room (still on the heap), then gives each friend who wants to read it a “library card” (clones an Rc pointer). It has an internal counter that records how many “library cards” have been issued.\nuse std::rc::Rc; // Manage the comic book \"Rust from Beginner to Giving Up\" with Rc let book = Rc::new(String::from(\"Rust from Beginner to Giving Up\")); println!(\"Current readers: {}\", Rc::strong_count(\u0026book)); // Output 1, just yourself // Friend A borrowed it let friend_a = Rc::clone(\u0026book); println!(\"Current readers: {}\", Rc::strong_count(\u0026book)); // Output 2 // Friend B also borrowed it let friend_b = Rc::clone(\u0026book); println!(\"Current readers: {}\", Rc::strong_count(\u0026book)); // Output 3 When a friend finishes reading and destroys their “library card” (variable leaves scope), the counter decreases by one. When the counter reaches zero, it means no one is reading this comic book anymore, and the librarian Rc will dispose of the book and reclaim memory.\nBut remember! Toys managed by Rc can only be looked at, not modified! If anyone dares to scribble on them (modify data), the compiler will be the first to spank your bottom. This is for safety, to prevent data races.\nToy Box #3: RefCell — “Secretly, I have a way to modify it while everyone is looking” “Only look, no modify? That’s too inflexible!” you might complain.\nDon’t worry, Rust provides a “cheat device”, a real black magic — RefCell.\nRefCell is like a transparent display case with a runtime lock. Under normal circumstances, it’s like Rc, allowing multiple people to “observe” (shared references). But it secretly provides a special key that lets you apply for “temporary modification rights” at runtime (when the program is running).\nIt bypasses the compiler’s static borrowing checks and postpones the checking work to runtime.\nuse std::cell::RefCell; let shared_data = RefCell::new(5); // Everyone can look println!(\"Original data: {:?}\", shared_data.borrow()); // I want to modify it, apply for a mutable borrow let mut mutable_borrow = shared_data.borrow_mut(); *mutable_borrow += 1; // After modification, others see the new data println!(\"Modified data: {:?}\", shared_data.borrow()); // Output 6 Sounds great? But black magic always has a price!\nThe cost of RefCell is: if you don’t follow the rules, it won’t tell you at compile time, but will directly crash your program (panic) at runtime!\nIts rules are:\nAt any time, you can only have one “mutable borrow” (borrow_mut). When you have a “mutable borrow”, you can’t have any “immutable borrows” (borrow). If you apply for two borrow_mut at the same time, or try to borrow while borrow_mut still exists, the program will shout “You violated the rules!” and explode on the spot.\nUltimate Combination: Rc","wordCount":"1088","inLanguage":"en","image":"https://rexai.top/cover.png","datePublished":"2024-01-15T10:00:00+08:00","dateModified":"2024-01-15T10:00:00+08:00","author":{"@type":"Person","name":"Dream Beast Programming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/"},"publisher":{"@type":"Organization","name":"梦兽编程","logo":{"@type":"ImageObject","url":"https://rexai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rexai.top/ accesskey=h title="梦兽编程 (Alt + H)">梦兽编程</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://rexai.top/zh-cn/ title=中文 aria-label=中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://rexai.top/ title=Home><span>Home</span></a></li><li class=has-submenu><a href=https://rexai.top/tutorials/ title="📚 Tutorials"><span>📚 Tutorials</span>
<span class=submenu-toggle>▼</span></a><ul class=submenu><li><a href=https://rexai.top/tutorials/rust/ title=Rust>Rust</a></li><li><a href=https://rexai.top/tutorials/ai/ title="AI Programming">AI Programming</a></li></ul></li><li><a href=https://rexai.top/tools/ title=Tools><span>Tools</span></a></li><li><a href=https://rexai.top/news/ title="🔥 News"><span>🔥 News</span></a></li><li><a href=https://rexai.top/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=https://rexai.top/categories/ title="📂 Categories"><span>📂 Categories</span></a></li></ul></nav></header><style>.has-submenu{position:relative}#menu{overflow:visible !important}#menu li{overflow:visible}.submenu{position:absolute;top:100%;left:0;background:var(--theme);border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);min-width:180px;z-index:1000;list-style:none;display:none;padding:.5rem 0}.submenu li{display:block;margin:0;line-height:1.5}#menu .submenu li+li{margin-inline-start:0}.submenu a{display:block;padding:.75rem 1rem;color:var(--secondary);text-decoration:none;transition:all .2s ease;border-radius:0}.submenu a:hover{background:var(--entry);color:var(--primary)}.has-submenu:hover .submenu{display:block !important}.submenu-toggle{margin-left:.25rem;font-size:.75rem;transition:transform .2s ease;display:inline-block}.has-submenu:hover .submenu-toggle{transform:rotate(180deg)}@media(max-width:768px){.submenu{position:static;box-shadow:none;border:none;background:var(--entry);margin-top:0;margin-left:1rem;display:none;padding:0}.has-submenu.active .submenu{display:block}.submenu-toggle{cursor:pointer}}</style><script>window.innerWidth<=768&&document.querySelectorAll(".has-submenu").forEach(e=>{const n=e.querySelector("a"),t=e.querySelector(".submenu-toggle");t&&(t.addEventListener("click",function(t){t.preventDefault(),e.classList.toggle("active")}),n.addEventListener("click",function(t){e.classList.contains("has-submenu")&&(t.preventDefault(),e.classList.toggle("active"))}))})</script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Complete Guide to Rust Smart Pointers: Master Box, Rc, and RefCell for Memory Management</h1><div class=post-description>Learn Rust smart pointers through vivid analogies and practical examples. Master Box, Rc, and RefCell to understand Rust's memory management system effortlessly</div><div class=post-meta><span title='2024-01-15 10:00:00 +0800 +0800'>January 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1088 words&nbsp;·&nbsp;Dream Beast Programming&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://rexai.top/zh-cn/tutorials/rust/rust-smart-pointers-explained-fun-way/>Zh-Cn</a></li></ul></div></header><figure class=entry-cover><img loading=eager srcset='https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/cover_hu_bd5ba7d9f164bd2b.png 360w,https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/cover_hu_b40deadde5cb8a0d.png 480w,https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/cover_hu_f3ed64763c7f428c.png 720w,https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/cover_hu_aaf42186d5af8180.png 1080w,https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/cover_hu_eb51aee2a3b8a40b.png 1500w,https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/cover.png 2163w' src=https://rexai.top/tutorials/rust/rust-smart-pointers-explained-fun-way/cover.png sizes="(min-width: 768px) 720px, 100vw" width=2163 height=1441 alt="Rust Smart Pointers: Box, Rc, RefCell"><figcaption>Complete Guide to Rust Smart Pointers</figcaption></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#rust-ownership-stop-memorizing-play-with-smart-pointers-as-toys---the-big-three-box-rc-refcell-will-make-memory-management-crystal-clear aria-label="Rust Ownership: Stop Memorizing! Play with Smart Pointers as &ldquo;Toys&rdquo; - The Big Three (Box, Rc, RefCell) Will Make Memory Management Crystal Clear">Rust Ownership: Stop Memorizing! Play with Smart Pointers as &ldquo;Toys&rdquo; - The Big Three (Box, Rc, RefCell) Will Make Memory Management Crystal Clear</a><ul><li><a href=#toy-box-1-boxt--this-toy-is-too-big-it-wont-fit-in-my-house aria-label="Toy Box #1: Box<T> — &ldquo;This toy is too big, it won&rsquo;t fit in my house!&rdquo;">Toy Box #1: Box&lt;T> — &ldquo;This toy is too big, it won&rsquo;t fit in my house!&rdquo;</a></li><li><a href=#toy-box-2-rct--my-toy-everyone-can-look-at-it-together aria-label="Toy Box #2: Rc<T> — &ldquo;My toy, everyone can look at it together!&rdquo;">Toy Box #2: Rc&lt;T> — &ldquo;My toy, everyone can look at it together!&rdquo;</a></li><li><a href=#toy-box-3-refcellt--secretly-i-have-a-way-to-modify-it-while-everyone-is-looking aria-label="Toy Box #3: RefCell<T> — &ldquo;Secretly, I have a way to modify it while everyone is looking&rdquo;">Toy Box #3: RefCell&lt;T> — &ldquo;Secretly, I have a way to modify it while everyone is looking&rdquo;</a></li><li><a href=#ultimate-combination-rcrefcellt--shared-ownership-plus-internal-modification aria-label="Ultimate Combination: Rc<RefCell<T>> — Shared Ownership, Plus Internal Modification!">Ultimate Combination: Rc&lt;RefCell&lt;T>> — Shared Ownership, Plus Internal Modification!</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=rust-ownership-stop-memorizing-play-with-smart-pointers-as-toys---the-big-three-box-rc-refcell-will-make-memory-management-crystal-clear>Rust Ownership: Stop Memorizing! Play with Smart Pointers as &ldquo;Toys&rdquo; - The Big Three (Box, Rc, RefCell) Will Make Memory Management Crystal Clear<a hidden class=anchor aria-hidden=true href=#rust-ownership-stop-memorizing-play-with-smart-pointers-as-toys---the-big-three-box-rc-refcell-will-make-memory-management-crystal-clear>#</a></h1><p>Hey there, friend! Still getting dizzy with Rust&rsquo;s ownership system? All that borrowing and lifetime stuff feeling like studying an incomprehensible legal code?</p><p>Don&rsquo;t worry! Today we&rsquo;re not going to talk about those big theories. Let&rsquo;s imagine the code world as a playground, data as beloved toys, and see how Rust makes memory management both safe and fun through several &ldquo;smart&rdquo; &ldquo;toy boxes&rdquo; (smart pointers).</p><h2 id=toy-box-1-boxt--this-toy-is-too-big-it-wont-fit-in-my-house>Toy Box #1: <code>Box&lt;T></code> — &ldquo;This toy is too big, it won&rsquo;t fit in my house!&rdquo;<a hidden class=anchor aria-hidden=true href=#toy-box-1-boxt--this-toy-is-too-big-it-wont-fit-in-my-house>#</a></h2><p>Imagine you bought an awesome LEGO Millennium Falcon, but it&rsquo;s too big for your small room (<strong>Stack</strong>) to hold. What do you do?</p><p>Your mom (the compiler) says: &ldquo;Silly child, if it doesn&rsquo;t fit, just rent an external storage locker (<strong>Heap</strong>)!&rdquo;</p><p><code>Box&lt;T></code> is that &ldquo;universal box&rdquo; that helps you rent a storage locker and put your toy inside.</p><p>It&rsquo;s simple, it does one thing: moves your data from the stack to the heap. And what do you hold? Just a &ldquo;key&rdquo; (pointer) pointing to the storage locker. This &ldquo;key&rdquo; itself is small, so your room (stack) can definitely hold it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Can&#39;t fit 1 million integers in the room (stack)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// let a = [0; 1000000]; // This might crash the program
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use Box to put it in the external storage locker (heap)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> Box::new([<span style=color:#ae81ff>0</span>; <span style=color:#ae81ff>1000000</span>]); <span style=color:#75715e>// Easy peasy!
</span></span></span></code></pre></div><p>Most importantly, this storage locker key can only have <strong>one</strong> owner at a time. If you give the key to your friend, you can&rsquo;t use it anymore. This is <code>Box&lt;T></code>&rsquo;s <strong>single ownership</strong>. When &ldquo;you&rdquo; (the variable holding the Box) leave the playground (scope), Rust automatically helps you return the storage locker, and the toys inside are destroyed, clean and tidy, never forgetful.</p><p><strong>When to use it?</strong></p><ol><li>When your &ldquo;toy&rdquo; is too big and won&rsquo;t fit on the stack.</li><li>When you need a &ldquo;toy list&rdquo; but each toy in the list has a different size (trait objects <code>Box&lt;dyn Trait></code>).</li><li>When you create a recursive toy that &ldquo;gives birth to itself&rdquo; (like a linked list).</li></ol><h2 id=toy-box-2-rct--my-toy-everyone-can-look-at-it-together>Toy Box #2: <code>Rc&lt;T></code> — &ldquo;My toy, everyone can look at it together!&rdquo;<a hidden class=anchor aria-hidden=true href=#toy-box-2-rct--my-toy-everyone-can-look-at-it-together>#</a></h2><p>Now, you have a limited edition comic book (a piece of data), and several of your friends (different parts of the code) want to read it.</p><p>If you use <code>Box</code>, you give the comic book (ownership) to friend A, and friends B and C can&rsquo;t read it. This obviously won&rsquo;t work - the ship of friendship will capsize.</p><p>So, <code>Rc&lt;T></code> (Reference Counting) makes its grand entrance! It&rsquo;s like a &ldquo;librarian&rdquo;.</p><p><code>Rc&lt;T></code> puts your comic book in a public reading room (still on the heap), then gives each friend who wants to read it a &ldquo;library card&rdquo; (clones an <code>Rc</code> pointer). It has an internal counter that records how many &ldquo;library cards&rdquo; have been issued.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::rc::Rc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Manage the comic book &#34;Rust from Beginner to Giving Up&#34; with Rc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> book <span style=color:#f92672>=</span> Rc::new(String::from(<span style=color:#e6db74>&#34;Rust from Beginner to Giving Up&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Current readers: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>book)); <span style=color:#75715e>// Output 1, just yourself
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Friend A borrowed it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> friend_a <span style=color:#f92672>=</span> Rc::clone(<span style=color:#f92672>&amp;</span>book);
</span></span><span style=display:flex><span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Current readers: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>book)); <span style=color:#75715e>// Output 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Friend B also borrowed it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> friend_b <span style=color:#f92672>=</span> Rc::clone(<span style=color:#f92672>&amp;</span>book);
</span></span><span style=display:flex><span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Current readers: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, Rc::strong_count(<span style=color:#f92672>&amp;</span>book)); <span style=color:#75715e>// Output 3
</span></span></span></code></pre></div><p>When a friend finishes reading and destroys their &ldquo;library card&rdquo; (variable leaves scope), the counter decreases by one. When the counter reaches zero, it means no one is reading this comic book anymore, and the librarian <code>Rc</code> will dispose of the book and reclaim memory.</p><p><strong>But remember!</strong> Toys managed by <code>Rc&lt;T></code> can only be <strong>looked at</strong>, not <strong>modified</strong>! If anyone dares to scribble on them (modify data), the compiler will be the first to spank your bottom. This is for safety, to prevent data races.</p><h2 id=toy-box-3-refcellt--secretly-i-have-a-way-to-modify-it-while-everyone-is-looking>Toy Box #3: <code>RefCell&lt;T></code> — &ldquo;Secretly, I have a way to modify it while everyone is looking&rdquo;<a hidden class=anchor aria-hidden=true href=#toy-box-3-refcellt--secretly-i-have-a-way-to-modify-it-while-everyone-is-looking>#</a></h2><p>&ldquo;Only look, no modify? That&rsquo;s too inflexible!&rdquo; you might complain.</p><p>Don&rsquo;t worry, Rust provides a &ldquo;cheat device&rdquo;, a real black magic — <code>RefCell&lt;T></code>.</p><p><code>RefCell&lt;T></code> is like a transparent display case with a <strong>runtime lock</strong>. Under normal circumstances, it&rsquo;s like <code>Rc</code>, allowing multiple people to &ldquo;observe&rdquo; (shared references). But it secretly provides a special key that lets you apply for &ldquo;temporary modification rights&rdquo; at <strong>runtime</strong> (when the program is running).</p><p>It bypasses the compiler&rsquo;s static borrowing checks and postpones the checking work to runtime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::cell::RefCell;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> shared_data <span style=color:#f92672>=</span> RefCell::new(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Everyone can look
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Original data: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, shared_data.borrow());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// I want to modify it, apply for a mutable borrow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> mutable_borrow <span style=color:#f92672>=</span> shared_data.borrow_mut();
</span></span><span style=display:flex><span><span style=color:#f92672>*</span>mutable_borrow <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// After modification, others see the new data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Modified data: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, shared_data.borrow()); <span style=color:#75715e>// Output 6
</span></span></span></code></pre></div><p><strong>Sounds great? But black magic always has a price!</strong></p><p>The cost of <code>RefCell&lt;T></code> is: if you don&rsquo;t follow the rules, it won&rsquo;t tell you at compile time, but will <strong>directly crash your program (panic) at runtime</strong>!</p><p>Its rules are:</p><ul><li>At any time, you can only have one &ldquo;mutable borrow&rdquo; (<code>borrow_mut</code>).</li><li>When you have a &ldquo;mutable borrow&rdquo;, you can&rsquo;t have any &ldquo;immutable borrows&rdquo; (<code>borrow</code>).</li></ul><p>If you apply for two <code>borrow_mut</code> at the same time, or try to <code>borrow</code> while <code>borrow_mut</code> still exists, the program will shout &ldquo;You violated the rules!&rdquo; and explode on the spot.</p><h2 id=ultimate-combination-rcrefcellt--shared-ownership-plus-internal-modification>Ultimate Combination: <code>Rc&lt;RefCell&lt;T>></code> — Shared Ownership, Plus Internal Modification!<a hidden class=anchor aria-hidden=true href=#ultimate-combination-rcrefcellt--shared-ownership-plus-internal-modification>#</a></h2><p>Alright, now let&rsquo;s combine toy boxes #2 and #3, and we get the ultimate artifact <code>Rc&lt;RefCell&lt;T>></code>.</p><p><code>Rc</code> is responsible for letting multiple owners <strong>share</strong> this &ldquo;transparent display case&rdquo;.
<code>RefCell</code> is responsible for letting people with permissions <strong>modify</strong> the things inside the case at runtime.</p><p>This is your perfect solution when you need &ldquo;multiple ownership&rdquo; and &ldquo;mutability&rdquo;. For example, in a graph structure, a node might be referenced by multiple other nodes, and its own state also needs to be modified.</p><p><strong>Summary: How to choose?</strong></p><ul><li>Want to put big things on the heap, and there&rsquo;s only one owner? Use <code>Box&lt;T></code>.</li><li>Want data to be shared read-only by multiple parts? Use <code>Rc&lt;T></code>.</li><li>Want to temporarily &ldquo;break&rdquo; borrowing rules in single-threaded code, implementing interior mutability? Use <code>RefCell&lt;T></code>.</li><li>Want data to be shared by multiple parts, and also modifiable? Use <code>Rc&lt;RefCell&lt;T>></code>.</li><li>(Secret preview) If you&rsquo;re playing with sharing and modification in a multi-threaded environment? Then you&rsquo;ll need atomic reference counting <code>Arc</code> and mutex locks <code>Mutex</code>, we&rsquo;ll cover that next time!</li></ul><p>See, through these vivid &ldquo;toy boxes&rdquo;, Rust&rsquo;s ownership and memory management suddenly becomes crystal clear, doesn&rsquo;t it?</p><p><strong>Follow Dream Beast Programming WeChat Official Account, unlock more black tech</strong>, let&rsquo;s make programming bloom with creativity!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rexai.top/tags/rust/>Rust</a></li><li><a href=https://rexai.top/tags/smart-pointers/>Smart Pointers</a></li><li><a href=https://rexai.top/tags/memory-management/>Memory Management</a></li><li><a href=https://rexai.top/tags/programming-tutorial/>Programming Tutorial</a></li><li><a href=https://rexai.top/tags/systems-programming/>Systems Programming</a></li></ul></footer></article></main><footer class=footer><span>© <a href=https://rexai.top/>梦兽编程</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>